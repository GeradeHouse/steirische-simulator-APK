# Project Overview (included; respecting .gitignore)
# Generated on: 2026-01-04 12:59:37
# Total included files: 127

# Project structure:
- android/ (76 files)

- App.tsx

- build_apk.ps1

- capacitor.config.ts

- components/ (7 files)
  - AccordionButton.tsx
  - MainStage.tsx
  - MidiControls.tsx
  - PianoRoll.tsx
  - ProjectLibrary.tsx
  - SoundControls.tsx
  - TopBar.tsx

- constants.ts

- dist_apk/ (5 files)

- helpers/ (6 files)
  - appConfig.ts
  - layout_apk.json
  - layout.json
  - layoutGenerator.ts
  - midiMap.ts
  - projectStorage.ts

- hooks/ (5 files)
  - useAudioController.ts
  - useBackgroundImage.ts
  - useLayoutEditor.ts
  - useMidiPlayer.ts
  - useSoundSettings.ts

- index.html

- index.tsx

- metadata.json

- package.json

- public/ (7 files)

- README.md

- services/ (7 files)
  - audio/
    - generators.ts
    - internalTypes.ts
    - master.ts
    - mechanics.ts
    - voice.ts
  - audioService.ts
  - geminiService.ts

- src/ (1 files)

- steirische-simulator-APK.code-workspace

- tsconfig.json

- types.ts

- vite.config.ts


# Project Files Listing

android/app/build.gradle:1-(55)
```
apply plugin: 'com.android.application'

android {
    namespace "com.steirische.simulator"
    compileSdk rootProject.ext.compileSdkVersion
    defaultConfig {
        applicationId "com.steirische.simulator"
        minSdkVersion rootProject.ext.minSdkVersion
        targetSdkVersion rootProject.ext.targetSdkVersion
        versionCode 2
        versionName "1.1"
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        aaptOptions {
             // Files and dirs to omit from the packaged assets dir.
             // Reverted to 'ignoreAssetsPattern' to match the working version
            ignoreAssetsPattern '!.svn:!.git:!.ds_store:!*.scc:.*:!CVS:!thumbs.db:!picasa.ini:!*~'
        }
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}

repositories {
    flatDir{
        dirs '../capacitor-cordova-android-plugins/src/main/libs', 'libs'
    }
}

dependencies {
    implementation fileTree(include: ['*.jar'], dir: 'libs')
    implementation "androidx.appcompat:appcompat:$androidxAppCompatVersion"
    implementation "androidx.coordinatorlayout:coordinatorlayout:$androidxCoordinatorLayoutVersion"
    implementation "androidx.core:core-splashscreen:$coreSplashScreenVersion"
    implementation project(':capacitor-android')
    testImplementation "junit:junit:$junitVersion"
    androidTestImplementation "androidx.test.ext:junit:$androidxJunitVersion"
    androidTestImplementation "androidx.test.espresso:espresso-core:$androidxEspressoCoreVersion"
    implementation project(':capacitor-cordova-android-plugins')
}

apply from: 'capacitor.build.gradle'

try {
    def servicesJSON = file('google-services.json')
    if (servicesJSON.text) {
        apply plugin: 'com.google.gms.google-services'
    }
} catch(Exception e) {
    logger.info("google-services.json not found, google-services plugin not applied. Push Notifications won't work")
}
```

android/app/capacitor.build.gradle:1-(20)
```
// DO NOT EDIT THIS FILE! IT IS GENERATED EACH TIME "capacitor update" IS RUN

android {
  compileOptions {
      sourceCompatibility JavaVersion.VERSION_17
      targetCompatibility JavaVersion.VERSION_17
  }
}

apply from: "../capacitor-cordova-android-plugins/cordova.variables.gradle"
dependencies {
    implementation project(':capacitor-app')

}


if (hasProperty('postBuildExtras')) {
  postBuildExtras()
}
```

android/app/proguard-rules.pro:1-(22)
```
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile
```

android/app/src/androidTest/java/com/getcapacitor/myapp/ExampleInstrumentedTest.java:1-(27)
```
package com.getcapacitor.myapp;

import static org.junit.Assert.*;

import android.content.Context;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.platform.app.InstrumentationRegistry;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Instrumented test, which will execute on an Android device.
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
@RunWith(AndroidJUnit4.class)
public class ExampleInstrumentedTest {

    @Test
    public void useAppContext() throws Exception {
        // Context of the app under test.
        Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();

        assertEquals("com.getcapacitor.app", appContext.getPackageName());
    }
}
```

android/app/src/main/AndroidManifest.xml:1-(38)
```
<?xml version="1.0" encoding="utf-8" ?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme"
        android:allowAudioPlaybackCapture="true">
        <activity
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|locale|smallestScreenSize|screenLayout|uiMode"
            android:name=".MainActivity"
            android:label="@string/title_activity_main"
            android:theme="@style/AppTheme.NoActionBarLaunch"
            android:launchMode="singleTask"
            android:screenOrientation="landscape"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <provider
            android:name="androidx.core.content.FileProvider"
            android:authorities="${applicationId}.fileprovider"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_paths" />
        </provider>
    </application>

    <!-- Permissions -->

    <uses-permission android:name="android.permission.INTERNET" />
</manifest>
```

android/app/src/main/java/com/steirische/simulator/MainActivity.java:1-(21)
```
package com.steirische.simulator;

import com.getcapacitor.BridgeActivity;
import android.view.View;

public class MainActivity extends BridgeActivity {
    @Override
    public void onWindowFocusChanged(boolean hasFocus) {
        super.onWindowFocusChanged(hasFocus);
        if (hasFocus) {
            getWindow().getDecorView().setSystemUiVisibility(
                View.SYSTEM_UI_FLAG_LAYOUT_STABLE
                | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
                | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
                | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
                | View.SYSTEM_UI_FLAG_FULLSCREEN
                | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY);
        }
    }
}
```

android/app/src/main/res/drawable-land-hdpi/splash.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/drawable-land-ldpi/splash.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/drawable-land-mdpi/splash.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/drawable-land-night-hdpi/splash.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/drawable-land-night-ldpi/splash.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/drawable-land-night-mdpi/splash.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/drawable-land-night-xhdpi/splash.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/drawable-land-night-xxhdpi/splash.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/drawable-land-night-xxxhdpi/splash.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/drawable-land-xhdpi/splash.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/drawable-land-xxhdpi/splash.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/drawable-land-xxxhdpi/splash.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/drawable-night/splash.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/drawable-port-hdpi/splash.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/drawable-port-ldpi/splash.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/drawable-port-mdpi/splash.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/drawable-port-night-hdpi/splash.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/drawable-port-night-ldpi/splash.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/drawable-port-night-mdpi/splash.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/drawable-port-night-xhdpi/splash.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/drawable-port-night-xxhdpi/splash.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/drawable-port-night-xxxhdpi/splash.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/drawable-port-xhdpi/splash.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/drawable-port-xxhdpi/splash.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/drawable-port-xxxhdpi/splash.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/drawable-v24/ic_launcher_foreground.xml:1-(35)
```
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt"
    android:width="108dp"
    android:height="108dp"
    android:viewportHeight="108"
    android:viewportWidth="108">
    <path
        android:fillType="evenOdd"
        android:pathData="M32,64C32,64 38.39,52.99 44.13,50.95C51.37,48.37 70.14,49.57 70.14,49.57L108.26,87.69L108,109.01L75.97,107.97L32,64Z"
        android:strokeColor="#00000000"
        android:strokeWidth="1">
        <aapt:attr name="android:fillColor">
            <gradient
                android:endX="78.5885"
                android:endY="90.9159"
                android:startX="48.7653"
                android:startY="61.0927"
                android:type="linear">
                <item
                    android:color="#44000000"
                    android:offset="0.0" />
                <item
                    android:color="#00000000"
                    android:offset="1.0" />
            </gradient>
        </aapt:attr>
    </path>
    <path
        android:fillColor="#FFFFFF"
        android:fillType="nonZero"
        android:pathData="M66.94,46.02L66.94,46.02C72.44,50.07 76,56.61 76,64L32,64C32,56.61 35.56,50.11 40.98,46.06L36.18,41.19C35.45,40.45 35.45,39.3 36.18,38.56C36.91,37.81 38.05,37.81 38.78,38.56L44.25,44.05C47.18,42.57 50.48,41.71 54,41.71C57.48,41.71 60.78,42.57 63.68,44.05L69.11,38.56C69.84,37.81 70.98,37.81 71.71,38.56C72.44,39.3 72.44,40.45 71.71,41.19L66.94,46.02ZM62.94,56.92C64.08,56.92 65,56.01 65,54.88C65,53.76 64.08,52.85 62.94,52.85C61.8,52.85 60.88,53.76 60.88,54.88C60.88,56.01 61.8,56.92 62.94,56.92ZM45.06,56.92C46.2,56.92 47.13,56.01 47.13,54.88C47.13,53.76 46.2,52.85 45.06,52.85C43.92,52.85 43,53.76 43,54.88C43,56.01 43.92,56.92 45.06,56.92Z"
        android:strokeColor="#00000000"
        android:strokeWidth="1" />
</vector>
```

android/app/src/main/res/drawable/ic_launcher_background.xml:1-(171)
```
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="108dp"
    android:height="108dp"
    android:viewportHeight="108"
    android:viewportWidth="108">
    <path
        android:fillColor="#26A69A"
        android:pathData="M0,0h108v108h-108z" />
    <path
        android:fillColor="#00000000"
        android:pathData="M9,0L9,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,0L19,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,0L29,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,0L39,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,0L49,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,0L59,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,0L69,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,0L79,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M89,0L89,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M99,0L99,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,9L108,9"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,19L108,19"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,29L108,29"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,39L108,39"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,49L108,49"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,59L108,59"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,69L108,69"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,79L108,79"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,89L108,89"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,99L108,99"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,29L89,29"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,39L89,39"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,49L89,49"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,59L89,59"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,69L89,69"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,79L89,79"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,19L29,89"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,19L39,89"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,19L49,89"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,19L59,89"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,19L69,89"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,19L79,89"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
</vector>
```

android/app/src/main/res/drawable/splash.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/layout/activity_main.xml:1-(13)
```
<?xml version="1.0" encoding="utf-8"?>
<androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <WebView
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
</androidx.coordinatorlayout.widget.CoordinatorLayout>
```

android/app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml:1-(9)
```
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background>
        <inset android:drawable="@mipmap/ic_launcher_background" android:inset="16.7%" />
    </background>
    <foreground>
        <inset android:drawable="@mipmap/ic_launcher_foreground" android:inset="16.7%" />
    </foreground>
</adaptive-icon>
```

android/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml:1-(9)
```
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background>
        <inset android:drawable="@mipmap/ic_launcher_background" android:inset="16.7%" />
    </background>
    <foreground>
        <inset android:drawable="@mipmap/ic_launcher_foreground" android:inset="16.7%" />
    </foreground>
</adaptive-icon>
```

android/app/src/main/res/mipmap-hdpi/ic_launcher_background.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/mipmap-hdpi/ic_launcher_foreground.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/mipmap-hdpi/ic_launcher_round.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/mipmap-hdpi/ic_launcher.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/mipmap-ldpi/ic_launcher_background.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/mipmap-ldpi/ic_launcher_foreground.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/mipmap-ldpi/ic_launcher_round.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/mipmap-ldpi/ic_launcher.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/mipmap-mdpi/ic_launcher_background.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/mipmap-mdpi/ic_launcher_foreground.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/mipmap-mdpi/ic_launcher_round.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/mipmap-mdpi/ic_launcher.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/mipmap-xhdpi/ic_launcher_background.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/mipmap-xhdpi/ic_launcher_foreground.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/mipmap-xhdpi/ic_launcher_round.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/mipmap-xhdpi/ic_launcher.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/mipmap-xxhdpi/ic_launcher_background.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/mipmap-xxhdpi/ic_launcher_foreground.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/mipmap-xxhdpi/ic_launcher_round.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/mipmap-xxhdpi/ic_launcher.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/mipmap-xxxhdpi/ic_launcher_background.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/mipmap-xxxhdpi/ic_launcher_foreground.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/mipmap-xxxhdpi/ic_launcher_round.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/mipmap-xxxhdpi/ic_launcher.png:1-(1)
```
# [binary file omitted]
```

android/app/src/main/res/values/colors.xml:1-(7)
```
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="colorPrimary">#6200EE</color>
    <color name="colorPrimaryDark">#3700B3</color>
    <color name="colorAccent">#03DAC5</color>
</resources>
```

android/app/src/main/res/values/ic_launcher_background.xml:1-(4)
```
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="ic_launcher_background">#FFFFFF</color>
</resources>
```

android/app/src/main/res/values/strings.xml:1-(8)
```
<?xml version='1.0' encoding='utf-8'?>
<resources>
    <string name="app_name">Steirische Simulator</string>
    <string name="title_activity_main">Steirische Simulator</string>
    <string name="package_name">com.steirische.simulator</string>
    <string name="custom_url_scheme">com.steirische.simulator</string>
</resources>
```

android/app/src/main/res/values/styles.xml:1-(22)
```
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <!-- Base application theme. -->
    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
        <!-- Customize your theme here. -->
        <item name="colorPrimary">@color/colorPrimary</item>
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>
    </style>

    <style name="AppTheme.NoActionBar" parent="Theme.AppCompat.DayNight.NoActionBar">
        <item name="windowActionBar">false</item>
        <item name="windowNoTitle">true</item>
        <item name="android:background">@null</item>
    </style>


    <style name="AppTheme.NoActionBarLaunch" parent="Theme.SplashScreen">
        <item name="android:background">@drawable/splash</item>
    </style>
</resources>
```

android/app/src/main/res/xml/file_paths.xml:1-(5)
```
<?xml version="1.0" encoding="utf-8"?>
<paths xmlns:android="http://schemas.android.com/apk/res/android">
    <external-path name="my_images" path="." />
    <cache-path name="my_cache_images" path="." />
</paths>
```

android/app/src/test/java/com/getcapacitor/myapp/ExampleUnitTest.java:1-(19)
```
package com.getcapacitor.myapp;

import static org.junit.Assert.*;

import org.junit.Test;

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
public class ExampleUnitTest {

    @Test
    public void addition_isCorrect() throws Exception {
        assertEquals(4, 2 + 2);
    }
}
```

android/build.gradle:1-(30)
```
// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    
    repositories {
        google()
        mavenCentral()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:8.2.1'
        classpath 'com.google.gms:google-services:4.4.0'

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

apply from: "variables.gradle"

allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}
```

android/capacitor.settings.gradle:1-(7)
```
// DO NOT EDIT THIS FILE! IT IS GENERATED EACH TIME "capacitor update" IS RUN
include ':capacitor-android'
project(':capacitor-android').projectDir = new File('../node_modules/@capacitor/android/capacitor')

include ':capacitor-app'
project(':capacitor-app').projectDir = new File('../node_modules/@capacitor/app/android')
```

android/gradle.properties:1-(22)
```
# Project-wide Gradle settings.

# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.

# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html

# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx1536m

# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true

# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app's APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
```

android/gradle/wrapper/gradle-wrapper.jar:1-(1)
```
# [binary file omitted]
```

android/gradle/wrapper/gradle-wrapper.properties:1-(8)
```
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.2.1-all.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
```

android/gradlew:1-(249)
```
#!/bin/sh

#
# Copyright ¬© 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions ¬´$var¬ª, ¬´${var}¬ª, ¬´${var:-default}¬ª, ¬´${var+SET}¬ª,
#           ¬´${var#prefix}¬ª, ¬´${var%suffix}¬ª, and ¬´$( cmd )¬ª;
#         * compound commands having a testable exit status, especially ¬´case¬ª;
#         * various built-in commands including ¬´command¬ª, ¬´set¬ª, and ¬´ulimit¬ª.
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
APP_HOME=$( cd "${APP_HOME:-./}" && pwd -P ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command;
#   * $DEFAULT_JVM_OPTS, $JAVA_OPTS, and $GRADLE_OPTS can contain fragments of
#     shell script including quotes and variable substitutions, so put them in
#     double quotes to make sure that they get re-expanded; and
#   * put everything else in single quotes, so that it's not re-expanded.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"
```

android/gradlew.bat:1-(93)
```
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
```

android/settings.gradle:1-(5)
```
include ':app'
include ':capacitor-cordova-android-plugins'
project(':capacitor-cordova-android-plugins').projectDir = new File('./capacitor-cordova-android-plugins/')

apply from: 'capacitor.settings.gradle'
```

android/variables.gradle:1-(16)
```
ext {
    minSdkVersion = 22
    compileSdkVersion = 34
    targetSdkVersion = 34
    androidxActivityVersion = '1.8.0'
    androidxAppCompatVersion = '1.6.1'
    androidxCoordinatorLayoutVersion = '1.2.0'
    androidxCoreVersion = '1.12.0'
    androidxFragmentVersion = '1.6.2'
    coreSplashScreenVersion = '1.0.1'
    androidxWebkitVersion = '1.9.0'
    junitVersion = '4.13.2'
    androidxJunitVersion = '1.1.5'
    androidxEspressoCoreVersion = '3.5.1'
    cordovaAndroidVersion = '10.1.1'
}
```

App.tsx:1-(301)
```
import React, { useRef, useState, useEffect, useCallback } from 'react';
import { MainStage } from './components/MainStage';
import { SoundControls } from './components/SoundControls';
import { MidiControls } from './components/MidiControls';
import { ProjectLibrary } from './components/ProjectLibrary';
import { Bars3Icon, XMarkIcon } from '@heroicons/react/24/outline';

import { useSoundSettings } from './hooks/useSoundSettings';
import { useLayoutEditor } from './hooks/useLayoutEditor';
import { useAudioController } from './hooks/useAudioController';
import { useBackgroundImage } from './hooks/useBackgroundImage';
import { useMidiPlayer } from './hooks/useMidiPlayer';
import { App as CapacitorApp } from '@capacitor/app';
import { saveProject } from './helpers/projectStorage';

export default function App() {
  const containerRef = useRef<HTMLDivElement>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  // --- UI State ---
  const [isMenuOpen, setIsMenuOpen] = useState(false);
  const [activeOverlay, setActiveOverlay] = useState<'sound' | 'projects' | null>(null);
  const [showTooltips, setShowTooltips] = useState(false);

  const {
    settings: soundSettings,
    updateSetting,
    resetSetting,
    resetAllSettings
  } = useSoundSettings();

  const {
    layout,
    isEditing,
    setIsEditing,
    selectedButtonId,
    setSelectedButtonId,
    dragTarget,
    handleDragStart,
    saveLayout,
    resetLayout,
    handleImportLayout,
    handleExportLayout
  } = useLayoutEditor(containerRef);

  const audioController = useAudioController(isEditing);
  const {
    direction,
    activeNotes,
    isAiEnabled,
    setIsAiEnabled,
    chordName,
    chordDesc,
    handleNoteStart,
    handleNoteStop
  } = audioController;

  const {
    bgImageSrc,
    bgStatus,
    manualPath,
    setManualPath,
    handleImgError,
    handleImgLoad,
    applyManualPath
  } = useBackgroundImage();

  const midiPlayer = useMidiPlayer(audioController);

  // --- Robust Auto-Save & Lifecycle ---
  const playerRef = useRef(midiPlayer);
  useEffect(() => { playerRef.current = midiPlayer; }, [midiPlayer]);

  // 1. Debounced Auto-Save
  useEffect(() => {
    if (!midiPlayer.isAutoSaveEnabled || !midiPlayer.currentProjectId) return;
    
    const save = () => {
       const state = midiPlayer.getProjectState();
       if (state && midiPlayer.currentProjectId) {
          saveProject({
             id: midiPlayer.currentProjectId,
             name: midiPlayer.fileName || 'Untitled Project',
             lastModified: Date.now(),
             ...state
          });
       }
    };

    const timer = setTimeout(save, 1000);
    return () => clearTimeout(timer);
  }, [
    midiPlayer.currentProjectId,
    midiPlayer.bpm,
    midiPlayer.octaveShift,
    midiPlayer.semitoneShift,
    midiPlayer.channelModes,
    midiPlayer.directionEvents,
    midiPlayer.fingeringOverrides,
    midiPlayer.isAutoSaveEnabled,
    midiPlayer.fileName
  ]);

  // 2. Immediate Save on App Pause/Background
  useEffect(() => {
    const handlePause = () => {
      const player = playerRef.current;
      if (player.isAutoSaveEnabled && player.currentProjectId) {
         const state = player.getProjectState();
         if (state) {
            saveProject({
               id: player.currentProjectId,
               name: player.fileName || 'Untitled Project',
               lastModified: Date.now(),
               ...state
            });
         }
      }
    };
    
    const listener = CapacitorApp.addListener('pause', handlePause);
    return () => { listener.then(l => l.remove()); };
  }, []);

  const onFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      handleImportLayout(file);
      e.target.value = '';
    }
  };

  const triggerImport = () => {
    if (fileInputRef.current) fileInputRef.current.click();
  };

  const handleBgDoubleClick = () => {
    if (isEditing) setSelectedButtonId(null);
  };

  return (
    <div className="w-screen h-screen bg-gray-100 overflow-hidden relative select-none">
      <input
        type="file"
        ref={fileInputRef}
        style={{ display: 'none' }}
        accept=".json"
        onChange={onFileChange}
      />

      {/* --- Main Stage (Full Screen) --- */}
      <div className="absolute inset-0 flex flex-col">
        <MainStage
          containerRef={containerRef}
          bgImageSrc={bgImageSrc}
          bgStatus={bgStatus}
          handleImgError={handleImgError}
          handleImgLoad={handleImgLoad}
          manualPath={manualPath}
          setManualPath={setManualPath}
          applyManualPath={applyManualPath}
          layout={layout}
          direction={direction}
          activeNotes={activeNotes}
          isEditing={isEditing}
          dragTarget={dragTarget}
          selectedButtonId={selectedButtonId}
          handleDragStart={handleDragStart}
          handleNoteStart={handleNoteStart}
          handleNoteStop={handleNoteStop}
          handleBgDoubleClick={handleBgDoubleClick}
          showTooltips={showTooltips}
          midiData={{
            notes: midiPlayer.allNotes,
            currentTime: midiPlayer.currentTime,
            channelModes: midiPlayer.channelModes,
            onSeek: midiPlayer.seek,
            octaveShift: midiPlayer.octaveShift,
            semitoneShift: midiPlayer.semitoneShift,
            directionEvents: midiPlayer.directionEvents,
            onUpdateDirections: midiPlayer.updateDirections,
            alternativeButtons: midiPlayer.alternativeButtons,
            onFingeringOverride: midiPlayer.setFingeringOverride,
            isPlaying: midiPlayer.isPlaying,
            editingNote: midiPlayer.editingNote,
            onSelectNote: midiPlayer.selectNote,
            onClearSelection: midiPlayer.clearSelection,
            autoScrollMode: midiPlayer.autoScrollMode,
            isNoteSnapEnabled: midiPlayer.isNoteSnapEnabled
          }}
        />
        <MidiControls
          player={midiPlayer}
          showTooltips={showTooltips}
          onToggleTooltips={() => setShowTooltips(!showTooltips)}
          onOpenLibrary={() => setActiveOverlay('projects')}
        />
      </div>

      {/* --- Floating Menu Button --- */}
      <button
        onClick={() => setIsMenuOpen(true)}
        className="absolute top-4 left-4 z-50 p-2.5 bg-white/90 backdrop-blur rounded-full shadow-lg border border-gray-300 text-gray-700 hover:bg-gray-50"
      >
        <Bars3Icon className="w-6 h-6" />
      </button>

      {/* --- Main Menu Modal --- */}
      {isMenuOpen && (
        <div className="absolute inset-0 z-[60] bg-black/60 backdrop-blur-sm flex items-center justify-center p-4" onClick={() => setIsMenuOpen(false)}>
          <div className="bg-white w-full max-w-sm rounded-2xl shadow-2xl overflow-hidden animate-in fade-in zoom-in duration-200" onClick={e => e.stopPropagation()}>
            <div className="p-4 border-b border-gray-100 flex justify-between items-center bg-gray-50">
              <h2 className="text-lg font-bold text-gray-800">Menu</h2>
              <button onClick={() => setIsMenuOpen(false)} className="p-1 text-gray-500"><XMarkIcon className="w-6 h-6"/></button>
            </div>
            
            <div className="p-4 space-y-3">
              <button onClick={() => { setActiveOverlay('sound'); setIsMenuOpen(false); }} className="w-full p-4 bg-indigo-50 text-indigo-900 rounded-xl font-bold text-left hover:bg-indigo-100 transition-colors">
                üéõÔ∏è Sound Settings
              </button>
              
              <button onClick={() => { setActiveOverlay('projects'); setIsMenuOpen(false); }} className="w-full p-4 bg-emerald-50 text-emerald-900 rounded-xl font-bold text-left hover:bg-emerald-100 transition-colors">
                üìÇ MIDI Projects
              </button>

              <div className="border-t border-gray-100 pt-3 mt-2">
                <div className="flex items-center justify-between p-2">
                  <span className="font-medium text-gray-700">Edit Layout</span>
                  <input
                    type="checkbox"
                    checked={isEditing}
                    onChange={(e) => setIsEditing(e.target.checked)}
                    className="w-5 h-5 accent-indigo-600"
                  />
                </div>
                
                {isEditing && (
                  <div className="grid grid-cols-2 gap-2 mt-2 px-2">
                    <button onClick={saveLayout} className="bg-indigo-600 text-white py-2 rounded-lg text-sm font-bold">Save Layout</button>
                    <button onClick={resetLayout} className="bg-red-100 text-red-600 py-2 rounded-lg text-sm font-bold">Reset</button>
                    <button onClick={triggerImport} className="col-span-2 bg-gray-100 text-gray-600 py-2 rounded-lg text-sm">Import JSON</button>
                    <button onClick={handleExportLayout} className="col-span-2 bg-gray-100 text-gray-600 py-2 rounded-lg text-sm">Export JSON</button>
                  </div>
                )}
              </div>

              <div className="border-t border-gray-100 pt-3">
                <div className="flex items-center justify-between p-2">
                  <span className="font-medium text-gray-700">AI Analysis</span>
                  <input
                    type="checkbox"
                    checked={isAiEnabled}
                    onChange={(e) => setIsAiEnabled(e.target.checked)}
                    className="w-5 h-5 accent-purple-600"
                  />
                </div>
                {isAiEnabled && (
                  <div className="bg-purple-50 p-3 rounded-lg mt-2 text-center">
                    <div className="font-bold text-purple-900">{chordName || "Waiting for input..."}</div>
                    <div className="text-xs text-purple-700">{chordDesc}</div>
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>
      )}

      {/* --- Full Screen Overlays --- */}
      {activeOverlay && (
        <div className="absolute inset-0 z-[55] bg-white flex flex-col animate-in slide-in-from-bottom duration-300">
          <div className="flex items-center justify-between p-3 border-b bg-gray-50 shadow-sm flex-none">
            <h3 className="font-bold text-lg text-gray-800 pl-2">
              {activeOverlay === 'sound' ? 'Sound Module' : 'MIDI Projects'}
            </h3>
            <button
              onClick={() => setActiveOverlay(null)}
              className="p-2 bg-white border border-gray-200 rounded-full text-gray-600 hover:bg-gray-100"
            >
              <XMarkIcon className="w-6 h-6" />
            </button>
          </div>
          <div className="flex-1 overflow-hidden relative">
            {activeOverlay === 'sound' ? (
              <SoundControls
                settings={soundSettings}
                onUpdate={updateSetting}
                onReset={resetSetting}
                onResetAll={resetAllSettings}
              />
            ) : (
              <div className="h-full p-4 overflow-y-auto">
                <ProjectLibrary player={midiPlayer} />
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
}
```

build_apk.ps1:1-(98)
```
$ErrorActionPreference = 'Stop'

function Die ($msg) {
    Write-Error "FAILED: $msg"
    exit 1
}

# 1. Detect Root
$root = Get-Location
if (!(Test-Path "$root\package.json") -or !(Test-Path "$root\android")) {
    Die "Please run this script from the project root (containing package.json and android/)."
}

# 2. Clean Android
Write-Host "--- [1/5] Cleaning Android Build ---" -ForegroundColor Cyan
Push-Location "$root\android"
try {
    .\gradlew clean
    if ($LASTEXITCODE -ne 0) { Die "gradlew clean failed" }
} finally { Pop-Location }

# 3. Install Dependencies
Write-Host "--- [2/5] Installing Dependencies ---" -ForegroundColor Cyan
npm install
if ($LASTEXITCODE -ne 0) { Die "npm install failed" }

# 4. Build Web Assets
Write-Host "--- [3/5] Building Web Assets ---" -ForegroundColor Cyan
npm run build
if ($LASTEXITCODE -ne 0) { Die "npm run build failed" }

# 5. Sync Capacitor
Write-Host "--- [4/5] Syncing Capacitor ---" -ForegroundColor Cyan
npx cap sync
if ($LASTEXITCODE -ne 0) { Die "npx cap sync failed" }

# 6. Assemble Debug APK
Write-Host "--- [5/5] Assembling APK ---" -ForegroundColor Cyan
Push-Location "$root\android"
try {
    .\gradlew assembleDebug
    if ($LASTEXITCODE -ne 0) { Die "gradlew assembleDebug failed" }
} finally { Pop-Location }

# 7. Copy to Drive (Staged)
$src = "$root\android\app\build\outputs\apk\debug\app-debug.apk"
$timestamp = Get-Date -Format "yyyyMMdd-HHmmss"
$fileName = "Steirische-v1.1-$timestamp.apk"
$driveDir = "G:\My Drive\Steirische Simulator"
$drivePath = "$driveDir\$fileName"

# 1. Local Staging (Crucial to break file locks)
$localStageDir = "$root\dist_apk"
if (!(Test-Path $localStageDir)) { New-Item -ItemType Directory -Force -Path $localStageDir | Out-Null }
$localPath = "$localStageDir\$fileName"

if (Test-Path $src) {
    # Step A: Copy to local folder first
    Write-Host "--- [1/2] Staging to $localPath ---" -ForegroundColor Cyan
    Copy-Item -Force $src $localPath
    
    # Wait for OS to flush file
    Start-Sleep -Seconds 2
    
    $stageFile = Get-Item $localPath
    if ($stageFile.Length -lt 1024) { Die "Build failed: APK is empty." }

    # Step B: Copy to Drive
    if (Test-Path $driveDir) {
        Write-Host "--- [2/2] Copying to Google Drive ---" -ForegroundColor Cyan
        
        # Use native copy for stability
        cmd /c copy /Y /B "$localPath" "$drivePath" | Out-Null
        
        Write-Host "SUCCESS: APK queued for upload." -ForegroundColor Green
        Write-Host "File: $fileName" -ForegroundColor Gray
        Write-Host "IMPORTANT: Wait for the green checkmark in Drive before opening!" -ForegroundColor Yellow
    } else {
        Write-Warning "Google Drive folder not found at: $driveDir"
        Write-Host "APK is available locally at: $localPath" -ForegroundColor Green
    }

    # Step C: Copy to OneDrive
    $oneDriveDir = "C:\Users\imede.IME-DEKKER\OneDrive\APK"
    $oneDrivePath = "$oneDriveDir\$fileName"

    if (Test-Path $oneDriveDir) {
        Write-Host "--- [3/3] Copying to OneDrive ---" -ForegroundColor Cyan
        Copy-Item -Force $localPath $oneDrivePath
        Write-Host "SUCCESS: APK copied to OneDrive." -ForegroundColor Green
        Write-Host "Location: $oneDrivePath" -ForegroundColor Gray
    } else {
        Write-Warning "OneDrive folder not found at: $oneDriveDir"
    }
} else {
    Die "APK file not found at $src"
}
```

capacitor.config.ts:1-(13)
```
import { CapacitorConfig } from '@capacitor/cli';

const config: CapacitorConfig = {
  appId: 'com.steirische.simulator',
  appName: 'Steirische Simulator',
  webDir: 'dist',
  server: {
    androidScheme: 'https'
  }
};

export default config;
```

components/AccordionButton.tsx:1-(289)
```
// file: components/AccordionButton.tsx
import React, { useRef, useState, useEffect } from 'react';
import { NoteDefinition, Direction } from '../types';

interface Props {
  pushNote: NoteDefinition;
  pullNote: NoteDefinition;
  direction: Direction;
  isActive: boolean;
  isSelected?: boolean;
  isBass?: boolean;
  isMarked?: boolean;
  isEditing?: boolean;
  idLabel?: string;
  isAlternative?: boolean;
  onAlternativeClick?: () => void;
  showTooltips?: boolean;
  onPlay: (note: NoteDefinition, direction: Direction) => void;
  onStop: () => void;
  onDragStart: (e: React.MouseEvent | React.TouchEvent) => void;
  style?: React.CSSProperties;
}

// Helper to separate "C#3 (des)" into { midi: "C#3", german: "des" }
const parseLabel = (fullLabel: string) => {
  const match = fullLabel.match(/^(.+?)\s*\((.+?)\)$/);
  if (match) {
    return { 
      midi: match[1].trim().replace(' Major', ''), 
      german: match[2].trim() 
    };
  }
  return { midi: fullLabel, german: fullLabel };
};

export const AccordionButton: React.FC<Props> = ({
  pushNote,
  pullNote,
  direction,
  isActive,
  isSelected,
  isBass,
  isMarked,
  isEditing,
  idLabel,
  isAlternative,
  onAlternativeClick,
  showTooltips = true,
  onPlay,
  onStop,
  onDragStart,
  style
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const [showTooltip, setShowTooltip] = useState(false);
  const isInteractionRef = useRef(false);

  const handleStop = () => {
    isInteractionRef.current = false;
    onStop();
  };

  const pushData = parseLabel(pushNote.label);
  const pullData = parseLabel(pullNote.label);

  // --- Styles ---
  const containerStyle = "rounded-full overflow-hidden shadow-sm transition-all duration-75 select-none absolute touch-none flex flex-col aspect-square pointer-events-auto";
  const cursorClass = isEditing ? "cursor-move" : "cursor-pointer";
  
  const borderClass = (isEditing && isSelected) 
    ? "ring-2 ring-blue-500 z-30" 
    : "border border-[#b0a890] hover:border-[#8c8272]";

  const markedClass = (!isEditing && isMarked) ? 'ring-2 ring-red-400/50 ring-offset-1 ring-offset-transparent' : '';

  const getTextStyle = (isActiveDir: boolean) => {
    const weight = isActiveDir ? "font-bold" : "font-normal";
    const size = isBass
      ? (isActiveDir ? "0.45rem" : "0.4rem")
      : (isActiveDir ? "0.5rem" : "0.45rem");
    return `text-[${size}] ${weight} leading-tight`;
  };
  const commonTextClasses = "w-full h-full flex justify-center text-black";

  // Active State Visuals
  const isPushActive = isActive && direction === Direction.PUSH;
  const isPullActive = isActive && direction === Direction.PULL;
  // Changed from yellow to bright blue with a background tint for better visibility
  const activeRingClass = "ring-2 ring-inset ring-blue-600 z-20 shadow-[inset_0_0_15px_rgba(37,99,235,0.5)] bg-blue-400/20";
  const alternativeRingClass = "ring-2 ring-inset ring-blue-300 bg-blue-300/40 z-30";

  // --- 1. Tooltip Delay Logic ---
  // Only show tooltip if the note has been active for >100ms.
  // This prevents tooltips from flashing during fast glissando playing.
  useEffect(() => {
    let timer: number;
    if (isActive && !isEditing) {
      timer = window.setTimeout(() => {
        setShowTooltip(true);
      }, 100); 
    } else {
      setShowTooltip(false);
    }
    return () => clearTimeout(timer);
  }, [isActive, isEditing]);

  // --- 2. Global Safety Check ---
  // If the note is active, watch the GLOBAL mouse position.
  // If the mouse escapes the button rect (even if mouseleave missed it), stop the note.
  useEffect(() => {
    if (!isActive || isEditing) return;

    const handleGlobalMove = (e: MouseEvent) => {
      if (!isInteractionRef.current) return;

      if (containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect();
        // Check if cursor is outside the button
        const isOutside =
          e.clientX < rect.left ||
          e.clientX > rect.right ||
          e.clientY < rect.top ||
          e.clientY > rect.bottom;
        
        if (isOutside) {
          handleStop();
        }
      }
    };

    const handleGlobalUp = () => {
      if (isInteractionRef.current) {
        handleStop();
      }
    };

    window.addEventListener('mousemove', handleGlobalMove);
    window.addEventListener('mouseup', handleGlobalUp);

    return () => {
      window.removeEventListener('mousemove', handleGlobalMove);
      window.removeEventListener('mouseup', handleGlobalUp);
    };
  }, [isActive, isEditing, onStop]);

  // --- Logic Helpers ---

  const getTargetFromEvent = (clientY: number) => {
    if (!containerRef.current) return null;
    const rect = containerRef.current.getBoundingClientRect();
    const relativeY = clientY - rect.top;
    const isTop = relativeY < (rect.height / 2);
    
    return {
      dir: isTop ? Direction.PUSH : Direction.PULL,
      note: isTop ? pushNote : pullNote
    };
  };

  const triggerNote = (clientY: number) => {
    const target = getTargetFromEvent(clientY);
    if (!target) return;

    if (isActive && direction === target.dir) return;

    if (isActive) {
      onStop();
    }

    onPlay(target.note, target.dir);
  };

  // --- Event Handlers ---

  const handleMouseDown = (e: React.MouseEvent) => {
    if (isEditing) {
      onDragStart(e);
      return;
    }
    
    // Intercept for alternative selection
    if (isAlternative && onAlternativeClick) {
        e.preventDefault();
        e.stopPropagation();
        onAlternativeClick();
        return;
    }

    if (e.button !== 0) return;
    e.preventDefault();
    isInteractionRef.current = true;
    triggerNote(e.clientY);
  };

  const handleMouseMove = (e: React.MouseEvent) => {
    if (isEditing) return;
    if (e.buttons === 1) {
      e.preventDefault();
      isInteractionRef.current = true;
      triggerNote(e.clientY);
    }
  };

  const handleTouchStart = (e: React.TouchEvent) => {
    if (isEditing) {
      onDragStart(e);
      return;
    }
    e.preventDefault();
    isInteractionRef.current = true;
    triggerNote(e.touches[0].clientY);
  };

  const handleTouchMove = (e: React.TouchEvent) => {
    if (isEditing) return;
    if (e.cancelable) e.preventDefault();
    triggerNote(e.touches[0].clientY);
  };

  return (
    <>
      {/* Main Container */}
      <div
        ref={containerRef}
        className={`${containerStyle} ${cursorClass} ${borderClass} ${markedClass}`}
        style={style}
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleStop}
        onMouseLeave={handleStop}
        onTouchStart={handleTouchStart}
        onTouchMove={handleTouchMove}
        onTouchEnd={handleStop}
        onTouchCancel={handleStop}
        onDragStart={(e) => { if (!isEditing) e.preventDefault(); }}
      >
        {/* Top Half (Push) */}
        <div className={`flex-1 w-full bg-[#F8FAEB] relative rounded-t-full pointer-events-none border-b border-[#d1cbb8] transition-all duration-75 ${
            isPushActive
              ? activeRingClass
              : (isAlternative && direction === Direction.PUSH ? alternativeRingClass : '')
          }`}>
          <div className={`${commonTextClasses} ${getTextStyle(direction === Direction.PUSH)} items-end pb-[1px]`}>
            {pushData.midi}
          </div>
        </div>

        {/* Bottom Half (Pull) */}
        <div className={`flex-1 w-full bg-[#E5DDBA] relative rounded-b-full pointer-events-none transition-all duration-75 ${
            isPullActive
              ? activeRingClass
              : (isAlternative && direction === Direction.PULL ? alternativeRingClass : '')
          }`}>
          <div className={`${commonTextClasses} ${getTextStyle(direction === Direction.PULL)} items-start pt-[1px]`}>
            {pullData.midi}
          </div>
        </div>

        {/* Debug/Editing ID Label */}
        {idLabel && (
          <div className="absolute inset-0 flex items-center justify-center pointer-events-none z-40">
             <span className={`bg-white/80 px-1 rounded text-[8px] font-bold text-red-600 ${isActive || isEditing ? 'opacity-100' : 'opacity-0'}`}>
              {idLabel}
            </span>
          </div>
        )}
      </div>
      
      {/* Active Note Pop-up (Debounced) */}
      {showTooltip && showTooltips && !isEditing && (
        <div 
            className="absolute z-50 pointer-events-none select-none"
            style={{ 
                left: style?.left, 
                top: style?.top, 
                width: 'auto',
                transform: 'translate(-50%, -140%)' 
            }}
        >
          <div className="flex flex-col items-center bg-gray-900/90 text-white text-xs rounded px-2 py-1 shadow-xl backdrop-blur-sm whitespace-nowrap">
            <span className="font-bold text-yellow-400">
              {direction === Direction.PUSH ? pushData.german : pullData.german}
            </span>
          </div>
        </div>
      )}
    </>
  );
};
```

components/MainStage.tsx:1-(306)
```
import React, { useMemo } from 'react';
import { Capacitor } from '@capacitor/core';
import { Direction, NoteDefinition, LayoutMap } from '../types';
import { TREBLE_ROWS, BASS_ROWS } from '../constants';
import { AccordionButton } from './AccordionButton';
import { PianoRoll } from './PianoRoll';
import { CANDIDATE_PATHS, SPLIT_LEFT_LIMIT, SPLIT_RIGHT_START } from '../helpers/appConfig';
import { DirectionEvent } from '../hooks/useMidiPlayer';
import { getButtonIdsForNote } from '../helpers/midiMap';
import {
  PencilSquareIcon,
  ExclamationTriangleIcon,
  PhotoIcon
} from '@heroicons/react/24/outline';

interface MainStageProps {
  containerRef: React.RefObject<HTMLDivElement>;
  bgImageSrc: string;
  bgStatus: 'loading' | 'loaded' | 'error';
  handleImgError: () => void;
  handleImgLoad: () => void;
  manualPath: string;
  setManualPath: (val: string) => void;
  applyManualPath: (e: React.FormEvent) => void;
  
  layout: LayoutMap;
  direction: Direction;
  activeNotes: Set<string>;
  isEditing: boolean;
  dragTarget: string | null;
  selectedButtonId: string | null;
  handleDragStart: (e: React.MouseEvent | React.TouchEvent, id: string) => void;
  handleNoteStart: (id: string, noteDef: NoteDefinition, type: 'bass' | 'chord' | 'treble', chordType?: any, direction?: Direction) => void;
  handleNoteStop: (id: string) => void;
  handleBgDoubleClick: () => void;
  showTooltips: boolean;
  
  midiData?: {
    notes: any[];
    currentTime: number;
    channelModes: any;
    onSeek: (t: number) => void;
    octaveShift: number;
    semitoneShift: number;
    directionEvents: DirectionEvent[];
    onUpdateDirections: (updates: any) => void;
    alternativeButtons?: Set<string>;
    onFingeringOverride?: (midi: number, time: number, channel: number, btnId: string) => void;
    isPlaying: boolean;
    editingNote?: { midi: number, time: number, channel: number } | null;
    onSelectNote?: (note: any) => void;
    onClearSelection?: () => void;
    flashingNotes?: Set<string>;
    autoScrollMode?: 'treble' | 'bass' | 'off';
    isNoteSnapEnabled?: boolean;
  };
}

export const MainStage: React.FC<MainStageProps> = ({
  containerRef,
  layout,
  direction,
  activeNotes,
  isEditing,
  dragTarget,
  selectedButtonId,
  handleDragStart,
  handleNoteStart,
  handleNoteStop,
  handleBgDoubleClick,
  showTooltips,
  midiData
}) => {
  
  const isAndroid = Capacitor.getPlatform() === 'android';
  const TREBLE_BTN_SIZE = isAndroid ? 5.8 : 3.4;
  const BASS_BTN_SIZE = isAndroid ? 5.9 : 4.3;

  // Adjust split start for Android (wider image: ~31.7% width vs 24%)
  const effectiveSplitRightStart = isAndroid ? 68.3 : SPLIT_RIGHT_START;

  // --- 1. Calculate Active MIDI Highlights ---
  const activeMidiHighlights = useMemo(() => {
    const highlights = new Set<string>();
    activeNotes.forEach(id => {
      const parts = id.split('-');
      if (parts.length !== 3) return;
      const type = parts[0];
      const r = parseInt(parts[1]);
      const b = parseInt(parts[2]);
      const rows = type === 'bass' ? BASS_ROWS : TREBLE_ROWS;
      const def = rows.find(row => row.rowId === r)?.buttons[b];
      if (def) {
        const noteDef = direction === Direction.PUSH ? def.push : def.pull;
        highlights.add(`${noteDef.midi}-${direction}`);
      }
    });
    return highlights;
  }, [activeNotes, direction]);

  // --- 2. Handle Piano Roll Note Preview ---
  const handlePianoRollPreview = (midi: number, dir: Direction, start: boolean) => {
    const btnIds = getButtonIdsForNote(midi, dir);
    btnIds.forEach(id => {
      if (start) {
        const parts = id.split('-');
        const typeStr = parts[0];
        const r = parseInt(parts[1]);
        const b = parseInt(parts[2]);
        const rows = typeStr === 'bass' ? BASS_ROWS : TREBLE_ROWS;
        const def = rows.find(row => row.rowId === r)?.buttons[b];
        if (def) {
          const noteDef = dir === Direction.PUSH ? def.push : def.pull;
          const type = noteDef.type as any;
          const chordType = noteDef.chordType;
          handleNoteStart(id, { midi, label: 'Preview' }, type, chordType, dir);
        }
      } else {
        handleNoteStop(id);
      }
    });
  };

  // --- 3. Coordinate Transformation Helper ---
  const transformStyle = (id: string, globalLeft: number, globalTop: number, size: number, panel: 'left' | 'right') => {
    let localLeft = 0;
    let localSize = 0;

    if (panel === 'left') {
      // Map 0 -> SPLIT_LEFT_LIMIT to 0 -> 100%
      localLeft = (globalLeft / SPLIT_LEFT_LIMIT) * 100;
      localSize = (size / SPLIT_LEFT_LIMIT) * 100;
    } else {
      // Map effectiveSplitRightStart -> 100 to 0 -> 100%
      const rightWidth = 100 - effectiveSplitRightStart;
      localLeft = ((globalLeft - effectiveSplitRightStart) / rightWidth) * 100;
      localSize = (size / rightWidth) * 100;
    }

    return {
      left: `${localLeft}%`,
      top: `${globalTop}%`, // Top remains relative to height (unchanged)
      width: `${localSize}%`,
      position: 'absolute' as const,
      transform: 'translate(-50%, -50%)',
      zIndex: isEditing && (dragTarget === id || selectedButtonId === id) ? 50 : 10
    };
  };

  const renderButton = (
    id: string,
    mapping: { push: NoteDefinition, pull: NoteDefinition, isMarked?: boolean },
    type: 'treble' | 'bass' | 'chord',
    chordType?: any
  ) => {
    const pos = layout[id] || { left: 50, top: 50 };
    const isActive = activeNotes.has(id);
    const isSelected = id === selectedButtonId;
    const isAlternative = midiData?.alternativeButtons?.has(id);
    const size = type === 'treble' ? TREBLE_BTN_SIZE : BASS_BTN_SIZE;
    
    // Determine Panel
    const isBassPanel = id.startsWith('bass');
    const panel = isBassPanel ? 'left' : 'right';
    const style = transformStyle(id, pos.left, pos.top, size, panel);

    const handleAlternativeClick = () => {
        if (!midiData?.onFingeringOverride) return;
        const currentMidiNote = midiData.notes.find(n => {
            const start = n.time;
            const end = n.time + n.duration;
            const t = midiData.currentTime;
            
            // Check time overlap
            if (t < start || t >= end) return false;

            // Check visibility (channel mode)
            const mode = midiData.channelModes[n.channel] || 'muted';
            if (mode === 'muted' || mode === 'hidden') return false;

            // Check pitch match (including semitone shift)
            const shifted = n.midi + (midiData.octaveShift * 12) + midiData.semitoneShift;
            const noteDef = direction === Direction.PUSH ? mapping.push : mapping.pull;
            return shifted === noteDef.midi;
        });
        if (currentMidiNote) {
            midiData.onFingeringOverride(currentMidiNote.midi, currentMidiNote.time, currentMidiNote.channel, id);
        }
    };

    return (
      <AccordionButton
        key={id}
        pushNote={mapping.push}
        pullNote={mapping.pull}
        direction={direction}
        isActive={isActive}
        isSelected={isSelected}
        isBass={type !== 'treble'}
        isMarked={mapping.isMarked}
        isEditing={isEditing}
        idLabel={isEditing ? id : undefined}
        isAlternative={isAlternative}
        onAlternativeClick={handleAlternativeClick}
        showTooltips={showTooltips}
        style={style}
        onDragStart={(e) => handleDragStart(e, id)}
        onPlay={(note, dir) => handleNoteStart(id, note, type, chordType, dir)}
        onStop={() => handleNoteStop(id)}
      />
    );
  };

  return (
    <div className="flex-1 relative overflow-hidden flex items-center justify-center p-0 bg-gray-100 select-none">
      
      {/* Main Flex Container */}
      <div
          ref={containerRef}
          className="relative flex w-full h-full max-h-full items-stretch justify-between overflow-hidden"
          onDoubleClick={handleBgDoubleClick}
          onMouseDown={(e) => {
            // Clear selection if clicking background (not buttons)
            if (midiData?.onClearSelection) midiData.onClearSelection();
          }}
      >
        
        {/* --- LEFT PANEL (Bass) --- */}
        <div className="relative h-full flex-none">
          <img
            src={isAndroid ? "assets/ui_bass_apk.png" : "assets/ui_bass.png"}
            alt="Bass Section"
            className="h-full w-auto object-contain pointer-events-none select-none"
          />
          {/* Overlay for Buttons */}
          <div className="absolute inset-0 z-10">
            {BASS_ROWS.map((row, rIdx) => (
                row.buttons.map((btn, bIdx) => renderButton(
                    `bass-${rIdx}-${bIdx}`, 
                    btn, 
                    btn.push.type === 'bass' ? 'bass' : 'chord',
                    btn.push.type === 'chord' ? btn.push.chordType : undefined
                ))
            ))}
          </div>
        </div>

        {/* --- MIDDLE PANEL (Bellows + Piano Roll) --- */}
        <div className="relative flex-1 h-full overflow-hidden">
          <img 
            src="assets/ui_bellow.png" 
            alt="Bellows" 
            className="w-full h-full object-fill pointer-events-none select-none opacity-90"
          />
          
          {/* Piano Roll Container */}
          {midiData && (
            <div className={`absolute ${Capacitor.getPlatform() === 'android' ? 'top-[4%] bottom-[12%]' : 'top-[18%] bottom-[18%]'} left-0 right-0 z-0 opacity-90 shadow-inner`}>
               <PianoRoll
                  notes={midiData.notes}
                  currentTime={midiData.currentTime}
                  isPlaying={midiData.isPlaying}
                  channelModes={midiData.channelModes}
                  direction={direction}
                  onSeek={midiData.onSeek}
                  octaveShift={midiData.octaveShift}
                  semitoneShift={midiData.semitoneShift}
                  directionEvents={midiData.directionEvents}
                  onUpdateDirections={midiData.onUpdateDirections}
                  activeMidiHighlights={activeMidiHighlights}
                  onNotePreview={handlePianoRollPreview}
                  editingNote={midiData.editingNote}
                  onSelectNote={midiData.onSelectNote}
                  onClearSelection={midiData.onClearSelection}
                  flashingNotes={midiData.flashingNotes}
                  autoScrollMode={midiData.autoScrollMode}
                  isNoteSnapEnabled={midiData.isNoteSnapEnabled}
                />
            </div>
          )}
        </div>

        {/* --- RIGHT PANEL (Treble) --- */}
        <div className="relative h-full flex-none">
          <img
            src={isAndroid ? "assets/ui_trebble_apk.png" : "assets/ui_trebble.png"}
            alt="Treble Section"
            className="h-full w-auto object-contain pointer-events-none select-none"
          />
          {/* Overlay for Buttons */}
          <div className="absolute inset-0 z-10">
            {TREBLE_ROWS.map((row, rIdx) => (
                row.buttons.map((btn, bIdx) => renderButton(
                    `treble-${rIdx}-${bIdx}`, 
                    btn, 
                    'treble'
                ))
            ))}
          </div>
        </div>

      </div>
    </div>
  );
};
```

components/MidiControls.tsx:1-(228)
```
import React, { useState } from 'react';
import {
  PlayIcon, PauseIcon, StopIcon, FolderOpenIcon,
  PlusIcon, MinusIcon, SpeakerWaveIcon, SpeakerXMarkIcon,
  ChevronUpIcon, ChevronDownIcon, ChatBubbleLeftEllipsisIcon, ArrowsUpDownIcon, BoltIcon
} from '@heroicons/react/24/solid';

interface Props {
  player: any; // ReturnType<typeof useMidiPlayer>
  showTooltips: boolean;
  onToggleTooltips: () => void;
  onOpenLibrary: () => void;
}

export const MidiControls: React.FC<Props> = ({ player, showTooltips, onToggleTooltips, onOpenLibrary }) => {
  const [isExpanded, setIsExpanded] = useState(false);
  const [isInputFocused, setIsInputFocused] = useState(false);

  const pressTimer = React.useRef<any>(null);
  const isLongPress = React.useRef(false);

  const handlePressStart = (ch: number) => {
    isLongPress.current = false;
    pressTimer.current = setTimeout(() => {
        isLongPress.current = true;
        if (window.confirm(`Delete Channel ${ch + 1}? This action cannot be undone.`)) {
            player.deleteChannel(ch);
        }
    }, 800);
  };

  const handlePressEnd = () => {
    if (pressTimer.current) {
        clearTimeout(pressTimer.current);
        pressTimer.current = null;
    }
  };

  const handleChannelClick = (ch: number) => {
    if (isLongPress.current) return;
    player.cycleChannelMode(ch);
  };

  const formatTime = (t: number) => {
    const m = Math.floor(t / 60);
    const s = Math.floor(t % 60);
    return `${m}:${s.toString().padStart(2, '0')}`;
  };

  return (
    <div className={`absolute left-1/2 -translate-x-1/2 bg-white/95 backdrop-blur border border-gray-300 p-2 rounded-2xl shadow-xl flex items-center gap-3 z-50 transition-all duration-300 max-w-[98vw] overflow-x-auto scrollbar-hide ${isInputFocused ? 'bottom-1/2' : 'bottom-1'}`}>
      
      {/* --- Transport (Always Visible) --- */}
      <div className="flex items-center gap-2 flex-none">
        <button
          onClick={player.togglePlay}
          disabled={!player.fileName}
          className="p-2 rounded-full bg-indigo-600 text-white hover:bg-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed shadow-sm"
        >
          {player.isPlaying ? <PauseIcon className="w-6 h-6" /> : <PlayIcon className="w-6 h-6" />}
        </button>

        <button
          onClick={player.resetPlayer}
          disabled={!player.fileName}
          className="p-2 rounded-full text-gray-600 hover:bg-gray-100 disabled:opacity-50"
        >
          <StopIcon className="w-6 h-6" />
        </button>
      </div>

      {/* --- Divider --- */}
      <div className="w-px h-8 bg-gray-300 flex-none"></div>

      {/* --- Expanded Controls --- */}
      {isExpanded && (
        <div className="flex items-center gap-3 animate-in fade-in slide-in-from-left-2 duration-200">
          {/* Library / Load Button */}
          <button
            onClick={onOpenLibrary}
            className="flex items-center gap-2 text-xs font-bold text-gray-600 hover:text-indigo-600 whitespace-nowrap"
          >
            <FolderOpenIcon className="w-5 h-5" />
            {player.fileName ? <span className="max-w-[80px] truncate">{player.fileName}</span> : "Load"}
          </button>

          <div className="w-px h-6 bg-gray-200"></div>

          {/* Channel Selector */}
          {player.availableChannels.length > 0 && (
            <div className="flex items-center gap-1">
              <span className="text-[10px] font-bold text-gray-400 uppercase">CH</span>
              <div className="flex gap-1">
                {player.availableChannels.map((ch: number) => {
                  const mode = player.channelModes[ch] || 'muted';
                  let bgClass = 'bg-gray-200 text-gray-500';
                  if (mode === 'bass') bgClass = 'bg-purple-600 text-white';
                  else if (mode === 'treble') bgClass = 'bg-green-600 text-white';
                  else if (mode === 'hidden') bgClass = 'bg-gray-800 text-gray-400 line-through';

                  return (
                    <button
                      key={ch}
                      onMouseDown={() => handlePressStart(ch)}
                      onMouseUp={handlePressEnd}
                      onMouseLeave={handlePressEnd}
                      onTouchStart={() => handlePressStart(ch)}
                      onTouchEnd={handlePressEnd}
                      onClick={() => handleChannelClick(ch)}
                      onContextMenu={(e) => e.preventDefault()}
                      className={`w-5 h-5 text-[9px] rounded flex items-center justify-center font-bold select-none touch-none ${bgClass}`}
                    >
                      {ch + 1}
                    </button>
                  );
                })}
              </div>
            </div>
          )}

          <div className="w-px h-6 bg-gray-200"></div>

          {/* Time & BPM */}
          <div className="flex flex-col text-[10px] text-gray-600 font-mono leading-tight">
            <span>{formatTime(player.currentTime)}</span>
            <span>{formatTime(player.totalTime)}</span>
          </div>

          <div className="flex items-center gap-1">
            <span className="text-[10px] font-bold text-gray-500">BPM</span>
            <input
              type="number"
              value={player.bpm}
              onChange={(e) => player.setBpm(Number(e.target.value))}
              onFocus={() => setIsInputFocused(true)}
              onBlur={() => setIsInputFocused(false)}
              onTouchStart={() => setIsInputFocused(true)}
              onKeyDown={(e) => e.key === 'Enter' && e.currentTarget.blur()}
              enterKeyHint="done"
              className="w-10 px-1 py-0.5 border rounded text-xs text-center"
            />
          </div>

          {/* Octave Shift */}
          <div className="flex items-center border rounded bg-gray-50">
            <button onClick={() => player.setOctaveShift(player.octaveShift - 1)} className="p-1 hover:bg-gray-200 text-gray-600">
              <MinusIcon className="w-3 h-3" />
            </button>
            <span className="text-xs font-mono w-5 text-center" title="Octave Shift">{player.octaveShift > 0 ? '+' : ''}{player.octaveShift}</span>
            <button onClick={() => player.setOctaveShift(player.octaveShift + 1)} className="p-1 hover:bg-gray-200 text-gray-600">
              <PlusIcon className="w-3 h-3" />
            </button>
          </div>

          {/* Semitone Shift */}
          <div className="flex items-center border rounded bg-gray-50">
            <button onClick={() => player.setSemitoneShift(player.semitoneShift - 1)} className="p-1 hover:bg-gray-200 text-gray-600">
              <MinusIcon className="w-3 h-3" />
            </button>
            <span className="text-xs font-mono w-5 text-center" title="Semitone Shift">{player.semitoneShift > 0 ? '+' : ''}{player.semitoneShift}</span>
            <button onClick={() => player.setSemitoneShift(player.semitoneShift + 1)} className="p-1 hover:bg-gray-200 text-gray-600">
              <PlusIcon className="w-3 h-3" />
            </button>
          </div>

          {/* Scrubbing Sound */}
          <button
            onClick={() => player.setIsScrubbingSoundEnabled(!player.isScrubbingSoundEnabled)}
            className={`p-1.5 rounded-full transition-colors ${
              player.isScrubbingSoundEnabled ? 'bg-indigo-100 text-indigo-600' : 'text-gray-400 hover:bg-gray-100'
            }`}
            title="Toggle Scrubbing Sound"
          >
            {player.isScrubbingSoundEnabled ? <SpeakerWaveIcon className="w-4 h-4" /> : <SpeakerXMarkIcon className="w-4 h-4" />}
          </button>

          {/* Auto Scroll Toggle */}
          <button
            onClick={player.cycleAutoScrollMode}
            className={`p-1.5 rounded-full transition-colors flex items-center gap-1 ${
              player.autoScrollMode === 'treble' ? 'bg-green-100 text-green-700' :
              player.autoScrollMode === 'bass' ? 'bg-purple-100 text-purple-700' :
              'text-gray-400 hover:bg-gray-100'
            }`}
            title={`Auto Scroll: ${player.autoScrollMode ? player.autoScrollMode.charAt(0).toUpperCase() + player.autoScrollMode.slice(1) : 'Off'}`}
          >
            <ArrowsUpDownIcon className="w-4 h-4" />
            <span className="text-[9px] font-bold uppercase w-3 text-center">
                {player.autoScrollMode === 'treble' ? 'T' : player.autoScrollMode === 'bass' ? 'B' : ''}
            </span>
          </button>

          {/* Snap Toggle */}
          <button
            onClick={() => player.setIsNoteSnapEnabled(!player.isNoteSnapEnabled)}
            className={`p-1.5 rounded-full transition-colors ${
              player.isNoteSnapEnabled ? 'bg-indigo-100 text-indigo-600' : 'text-gray-400 hover:bg-gray-100'
            }`}
            title="Toggle Note Snap"
          >
            <BoltIcon className="w-4 h-4" />
          </button>

          {/* Tooltips Toggle */}
          <button
            onClick={onToggleTooltips}
            className={`p-1.5 rounded-full transition-colors ${
              showTooltips ? 'bg-indigo-100 text-indigo-600' : 'text-gray-400 hover:bg-gray-100'
            }`}
            title="Toggle Note Names"
          >
            <ChatBubbleLeftEllipsisIcon className="w-4 h-4" />
          </button>
           
          <div className="w-px h-8 bg-gray-300 flex-none"></div>
        </div>
      )}

      {/* --- Toggle Button --- */}
      <button
        onClick={() => setIsExpanded(!isExpanded)}
        className="p-1 text-gray-400 hover:text-gray-600 flex-none"
      >
        {isExpanded ? <ChevronDownIcon className="w-5 h-5" /> : <ChevronUpIcon className="w-5 h-5" />}
      </button>
    </div>
  );
};
```

components/PianoRoll.tsx:1-(622)
```
import React, { useMemo, useState, useRef, useEffect } from 'react';
import { MidiNote, DirectionEvent } from '../hooks/useMidiPlayer';
import { ChannelMode } from '../hooks/useMidiPlayer';
import { Direction } from '../types';
import { getButtonIdsForNote, getNoteKey } from '../helpers/midiMap';
import { ExclamationTriangleIcon } from '@heroicons/react/24/solid';
import { ArrowRightIcon, ArrowLeftIcon } from '@heroicons/react/24/outline';

interface Props {
  notes: MidiNote[];
  currentTime: number;
  isPlaying: boolean;
  channelModes: Record<number, ChannelMode>;
  direction: Direction;
  onSeek: (time: number) => void;
  octaveShift: number;
  semitoneShift: number;
  directionEvents?: DirectionEvent[];
  onUpdateDirections?: (updates: { time: number, direction: Direction }[]) => void;
  activeMidiHighlights?: Set<string>;
  onNotePreview?: (midi: number, direction: Direction, start: boolean) => void;
  editingNote?: { midi: number, time: number, channel: number } | null;
  onSelectNote?: (note: MidiNote) => void;
  onClearSelection?: () => void;
  flashingNotes?: Set<string>;
  autoScrollMode?: 'treble' | 'bass' | 'off';
  isNoteSnapEnabled?: boolean;
}

// --- Hand-Drawn Note Component ---

const HandDrawnNote: React.FC<{
  width: number;
  height: number;
  label: string;
  hasMapping: boolean;
  isHighlighted: boolean;
  isEditing?: boolean;
  isFlashing?: boolean;
  mode: 'bass' | 'treble' | 'muted';
  wobbleId: string;
}> = ({ width, height, label, hasMapping, isHighlighted, isEditing, isFlashing, mode }) => {
  // Default: Muted (Grey)
  let border = '#9CA3AF'; // Gray 400
  let fill = '#E5E7EB';   // Gray 200
  let text = '#374151';   // Gray 700

  if (isFlashing) {
    border = '#EC4899'; // Pink 500
    fill = '#FBCFE8';   // Pink 200
    text = '#831843';   // Pink 900
  } else if (isEditing) {
    border = '#BE185D'; // Pink 700
    fill = '#F472B6';   // Pink 400
    text = '#FFFFFF';
  } else if (isHighlighted) {
    border = '#2563EB'; // Blue 600
    fill = '#3B82F6';   // Blue 500
    text = '#FFFFFF';
  } else if (mode === 'bass') {
    border = '#9333EA'; // Purple 600
    fill = '#D8B4FE';   // Purple 300
    text = '#581C87';   // Purple 900
  } else if (mode === 'treble') {
    border = '#16A34A'; // Green 600
    fill = '#86EFAC';   // Green 300
    text = '#14532D';   // Green 900
  }
  
  const pad = 2;
  const w = Math.max(0, width - pad * 2);
  const h = Math.max(0, height - pad * 2);

  return (
    <div className="w-full h-full relative">
      <svg width="100%" height="100%" style={{ overflow: 'visible' }}>
        <rect
          x={pad} y={pad} width={w} height={h} rx="4"
          fill={fill}
          stroke={border}
          strokeWidth="2"
        />
        <text
          x="50%" y="50%" dy=".35em"
          textAnchor="middle"
          fill={text}
          fontSize="11px"
          fontWeight="bold"
          style={{ pointerEvents: 'none', fontFamily: 'sans-serif' }}
        >
          {label}
        </text>
      </svg>
      
      {!hasMapping && mode !== 'muted' && (
        <div className="absolute -top-2 -right-2 bg-white rounded-full p-0.5 shadow-sm z-10">
          <ExclamationTriangleIcon className="w-3 h-3 text-red-600" />
        </div>
      )}
    </div>
  );
};

// --- Main Component ---

const getNoteLabel = (midi: number) => {
  const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
  const octave = Math.floor(midi / 12) - 1;
  const note = notes[midi % 12];
  return `${note}${octave}`;
};

const isBlackKey = (midi: number) => {
  const n = midi % 12;
  return n === 1 || n === 3 || n === 6 || n === 8 || n === 10;
};

export const PianoRoll: React.FC<Props> = ({
  notes,
  currentTime,
  isPlaying,
  channelModes,
  direction,
  onSeek,
  octaveShift,
  semitoneShift,
  directionEvents = [],
  onUpdateDirections,
  activeMidiHighlights,
  onNotePreview,
  editingNote,
  onSelectNote,
  onClearSelection,
  flashingNotes,
  autoScrollMode,
  isNoteSnapEnabled
}) => {
  // Configuration
  const PX_PER_SEC = 150;
  const NOTE_HEIGHT = 26; 
  const MIN_MIDI = 0;
  const MAX_MIDI = 127;
  const TOTAL_HEIGHT = (MAX_MIDI - MIN_MIDI + 1) * NOTE_HEIGHT;

  // Colors
  const ROW_BLACK = '#F0EEE8';
  const ROW_WHITE = '#FBFBF9';
  const KEY_BLACK = '#E5E7EB'; 
  const KEY_WHITE = '#FFFFFF';

  // State
  const [isDragging, setIsDragging] = useState(false);
  const [selectedTimes, setSelectedTimes] = useState<Set<number>>(new Set());
  
  // Refs
  const dragStartRef = useRef<{ x: number; time: number } | null>(null);
  const onSeekRef = useRef(onSeek);
  const scrollContainerRef = useRef<HTMLDivElement>(null);
  const contentRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    onSeekRef.current = onSeek;
  }, [onSeek]);

  // Auto-Scroll to Highest Note on Load
  useEffect(() => {
    if (notes.length === 0 || !scrollContainerRef.current) return;
    
    let maxMidi = 0;
    notes.forEach(n => {
      if (n.midi > maxMidi) maxMidi = n.midi;
    });
    
    // Calculate position of the highest note (using octaveShift * 12 + semitoneShift)
    const shiftedMax = maxMidi + (octaveShift * 12) + semitoneShift;
    const targetTop = (MAX_MIDI - shiftedMax) * NOTE_HEIGHT;
    
    // Scroll so the highest note is near the top (with 40px padding)
    scrollContainerRef.current.scrollTop = Math.max(0, targetTop - 40);
  }, [notes, octaveShift, semitoneShift, MAX_MIDI, NOTE_HEIGHT]);

  // --- Data Processing ---

  const visibleNotes = useMemo(() => {
    return notes.filter(n => {
      const mode = channelModes[n.channel] || 'muted';
      return mode !== 'hidden';
    });
  }, [notes, channelModes]);

  // Playback Auto-Scroll (Smooth Look-ahead)
  useEffect(() => {
    if (!isPlaying || !scrollContainerRef.current) return;
    if (autoScrollMode === 'off' || !autoScrollMode) return;

    const LOOK_AHEAD = 1.8; // Look 1.8 seconds ahead (more proactive)
    const PADDING = 50;     // Pixels from top
    const SMOOTHING = 0.08; // Faster catch-up (8% per frame)

    // Find notes in the look-ahead window [currentTime, currentTime + LOOK_AHEAD]
    const relevantNotes = visibleNotes.filter(n =>
      n.time < currentTime + LOOK_AHEAD &&
      (n.time + n.duration) > currentTime &&
      channelModes[n.channel] === autoScrollMode // 'treble' or 'bass' matches channel mode
    );

    if (relevantNotes.length === 0) return;

    // Find the highest pitch (Max MIDI) in this window
    let maxMidiInWindow = -Infinity;
    relevantNotes.forEach(n => {
      const shifted = n.midi + (octaveShift * 12) + semitoneShift;
      if (shifted > maxMidiInWindow) maxMidiInWindow = shifted;
    });

    if (maxMidiInWindow === -Infinity) return;

    // Calculate target scroll position
    // (MAX_MIDI - midi) * NOTE_HEIGHT is the top Y of the note row
    const targetTop = (MAX_MIDI - maxMidiInWindow) * NOTE_HEIGHT - PADDING;
    
    // Clamp target to valid scroll range
    const container = scrollContainerRef.current;
    const maxScroll = container.scrollHeight - container.clientHeight;
    const clampedTarget = Math.max(0, Math.min(targetTop, maxScroll));

    const currentScroll = container.scrollTop;
    
    // Smooth Interpolation (Lerp)
    const diff = clampedTarget - currentScroll;
    
    // Only scroll if difference is noticeable to avoid micro-jitter
    if (Math.abs(diff) > 1.0) {
       container.scrollTop = currentScroll + (diff * SMOOTHING);
    }
  }, [currentTime, isPlaying, visibleNotes, octaveShift, semitoneShift, MAX_MIDI, NOTE_HEIGHT, autoScrollMode, channelModes]);

  const arrowGroups = useMemo(() => {
    // Structure: time -> { bassMin, trebleMin }
    const groups: { time: number, bassMin: number | null, trebleMin: number | null }[] = [];
    const sorted = [...visibleNotes].sort((a, b) => a.time - b.time);
    
    sorted.forEach(note => {
      const mode = channelModes[note.channel] || 'muted';
      if (mode === 'muted') return;

      const lastGroup = groups[groups.length - 1];
      const isBass = mode === 'bass';
      
      // Group with last if within tolerance
      if (lastGroup && Math.abs(note.time - lastGroup.time) < 0.02) {
        if (isBass) {
            lastGroup.bassMin = lastGroup.bassMin === null ? note.midi : Math.min(lastGroup.bassMin, note.midi);
        } else {
            lastGroup.trebleMin = lastGroup.trebleMin === null ? note.midi : Math.min(lastGroup.trebleMin, note.midi);
        }
      } else {
        // Create new group
        groups.push({
            time: note.time,
            bassMin: isBass ? note.midi : null,
            trebleMin: !isBass ? note.midi : null
        });
      }
    });
    return groups;
  }, [visibleNotes, channelModes]);

  const getDirectionAtTime = (time: number) => {
    let dir = Direction.PUSH;
    for (const event of directionEvents) {
      if (event.time <= time + 0.001) {
        dir = event.direction;
      } else {
        break;
      }
    }
    return dir;
  };

  // --- Handlers ---

  const handleMouseDown = (e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();
    if (e.button === 0) {
        if (onClearSelection) onClearSelection();
        setIsDragging(true);
        dragStartRef.current = { x: e.clientX, time: currentTime };
    }
  };

  const handleTouchStart = (e: React.TouchEvent) => {
    e.stopPropagation();
    setIsDragging(true);
    dragStartRef.current = { x: e.touches[0].clientX, time: currentTime };
  };

  const handleArrowClick = (e: React.MouseEvent, time: number, currentDir: Direction) => {
      e.stopPropagation();
      if (!onUpdateDirections) return;
      
      const newSelected = new Set<number>(selectedTimes);
      if (!newSelected.has(time)) {
          newSelected.clear();
          newSelected.add(time);
          setSelectedTimes(newSelected);
      }

      let allSame = true;
      let firstDir: Direction | null = null;
      const updates: { time: number, direction: Direction }[] = [];
      
      const selectedDirs = new Map<number, Direction>();
      newSelected.forEach(t => {
          selectedDirs.set(t, getDirectionAtTime(t));
      });

      for (const d of selectedDirs.values()) {
          if (firstDir === null) firstDir = d;
          else if (firstDir !== d) {
              allSame = false;
              break;
          }
      }

      let targetDir: Direction;
      if (!allSame) {
          targetDir = currentDir; 
      } else {
          targetDir = firstDir === Direction.PUSH ? Direction.PULL : Direction.PUSH;
      }

      newSelected.forEach(t => {
          updates.push({ time: t, direction: targetDir });
      });

      onUpdateDirections(updates);
  };

  const handleNoteMouseDown = (e: React.MouseEvent, note: MidiNote, dir: Direction) => {
    e.stopPropagation();
    if (!isPlaying && onSelectNote) {
        onSelectNote(note);
    } else if (onNotePreview) {
        onNotePreview(note.midi, dir, true);
    }
  };

  const handleNoteMouseUp = (e: React.MouseEvent, midi: number, dir: Direction) => {
    e.stopPropagation();
    if (isPlaying && onNotePreview) onNotePreview(midi, dir, false);
  };

  useEffect(() => {
    const handleMouseMove = (e: MouseEvent) => {
      if (!isDragging || !dragStartRef.current) return;
      e.preventDefault();
      const dx = e.clientX - dragStartRef.current.x;
      let newTime = dragStartRef.current.time - (dx / PX_PER_SEC);

      if (isNoteSnapEnabled) {
          const SNAP_WINDOW = 0.15;
          let bestTime = newTime;
          let minDiff = SNAP_WINDOW;
          
          for (const note of visibleNotes) {
              if (note.time > newTime + SNAP_WINDOW) break;
              if (note.time < newTime - SNAP_WINDOW) continue;
              
              const diff = Math.abs(note.time - newTime);
              if (diff < minDiff) {
                  minDiff = diff;
                  bestTime = note.time;
              }
          }
          newTime = bestTime;
      }

      onSeekRef.current(newTime);
    };

    const handleTouchMove = (e: TouchEvent) => {
      if (!isDragging || !dragStartRef.current) return;
      e.preventDefault();
      const dx = e.touches[0].clientX - dragStartRef.current.x;
      let newTime = dragStartRef.current.time - (dx / PX_PER_SEC);

      if (isNoteSnapEnabled) {
          const SNAP_WINDOW = 0.15;
          let bestTime = newTime;
          let minDiff = SNAP_WINDOW;
          
          for (const note of visibleNotes) {
              if (note.time > newTime + SNAP_WINDOW) break;
              if (note.time < newTime - SNAP_WINDOW) continue;
              
              const diff = Math.abs(note.time - newTime);
              if (diff < minDiff) {
                  minDiff = diff;
                  bestTime = note.time;
              }
          }
          newTime = bestTime;
      }

      onSeekRef.current(newTime);
    };

    const handleEnd = () => {
      setIsDragging(false);
      dragStartRef.current = null;
    };

    if (isDragging) {
      window.addEventListener('mousemove', handleMouseMove);
      window.addEventListener('mouseup', handleEnd);
      window.addEventListener('touchmove', handleTouchMove, { passive: false });
      window.addEventListener('touchend', handleEnd);
    }
    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleEnd);
      window.removeEventListener('touchmove', handleTouchMove);
      window.removeEventListener('touchend', handleEnd);
    };
  }, [isDragging, PX_PER_SEC, isNoteSnapEnabled, visibleNotes]);

  const rows = useMemo(() => {
    const r = [];
    for (let m = MAX_MIDI; m >= MIN_MIDI; m--) {
      r.push(m);
    }
    return r;
  }, [MAX_MIDI, MIN_MIDI]);

  // Auto-Scroll to Highest Note on Load
  useEffect(() => {
    if (notes.length === 0 || !scrollContainerRef.current) return;
    
    let maxMidi = 0;
    notes.forEach(n => {
      if (n.midi > maxMidi) maxMidi = n.midi;
    });
    
    // Calculate position of the highest note (using octaveShift * 12 + semitoneShift)
    const shiftedMax = maxMidi + (octaveShift * 12) + semitoneShift;
    const targetTop = (MAX_MIDI - shiftedMax) * NOTE_HEIGHT;
    
    // Scroll so the highest note is near the top (with 40px padding)
    scrollContainerRef.current.scrollTop = Math.max(0, targetTop - 40);
  }, [notes, octaveShift, semitoneShift, MAX_MIDI, NOTE_HEIGHT]);

  // --- Data Processing ---

  return (
    <div 
      ref={scrollContainerRef}
      className="w-full h-full overflow-y-auto overflow-x-hidden bg-white border-2 border-gray-300 rounded-lg shadow-inner select-none relative"
    >

      <div className="relative" style={{ height: TOTAL_HEIGHT }}>
        
        {/* 1. Left Sidebar (Keys) */}
        <div className="absolute left-0 top-0 bottom-0 w-12 z-20 border-r border-gray-300 shadow-md bg-gray-50">
           {rows.map(midi => (
             <div 
               key={`key-${midi}`}
               className="flex items-center justify-center text-[10px] font-bold text-gray-600 border-b border-gray-200"
               style={{ 
                 height: NOTE_HEIGHT, 
                 backgroundColor: isBlackKey(midi) ? KEY_BLACK : KEY_WHITE,
                 fontFamily: '"Comic Sans MS", "Chalkboard SE", "Marker Felt", sans-serif'
               }}
             >
               {getNoteLabel(midi)}
             </div>
           ))}
        </div>

        {/* 2. Main Content Area */}
        <div
          ref={contentRef}
          className={`absolute top-0 bottom-0 left-12 right-0 ${isDragging ? 'cursor-grabbing' : 'cursor-grab'}`}
          onMouseDown={handleMouseDown}
          onTouchStart={handleTouchStart}
          onDoubleClick={() => setSelectedTimes(new Set())}
        >
           {/* Background Rows */}
           <div className="absolute inset-0 z-0 pointer-events-none">
             {rows.map(midi => (
               <div 
                 key={`row-${midi}`}
                 className="w-full border-b border-gray-100/50"
                 style={{ 
                   height: NOTE_HEIGHT, 
                   backgroundColor: isBlackKey(midi) ? ROW_BLACK : ROW_WHITE 
                 }}
               />
             ))}
           </div>

           {/* Playhead */}
           <div className="absolute left-[20%] top-0 bottom-0 w-0.5 bg-red-400/60 z-30 pointer-events-none shadow-[0_0_4px_rgba(248,113,113,0.5)]"></div>

           {/* Notes Container */}
           <div 
             className="absolute top-0 bottom-0 left-[20%] will-change-transform z-10"
             style={{ transform: `translateX(-${currentTime * PX_PER_SEC}px)` }}
           >
              {visibleNotes.map((note, idx) => {
                const left = note.time * PX_PER_SEC;
                const width = Math.max(note.duration * PX_PER_SEC, 10);
                const shiftedMidi = note.midi + (octaveShift * 12) + semitoneShift;
                const top = (MAX_MIDI - shiftedMidi) * NOTE_HEIGHT;
                const label = getNoteLabel(shiftedMidi);
                
                const noteDir = getDirectionAtTime(note.time);
                const mode = channelModes[note.channel] || 'muted';
                const allIds = getButtonIdsForNote(shiftedMidi, noteDir);
                const hasMapping = allIds.some(id => {
                  if (mode === 'treble') return id.startsWith('treble');
                  if (mode === 'bass') return id.startsWith('bass');
                  return true;
                });
                const highlightKey = `${shiftedMidi}-${noteDir}`;
                const isUnderPlayhead = currentTime >= note.time && currentTime < (note.time + note.duration);
                const isHighlighted = activeMidiHighlights?.has(highlightKey) && isUnderPlayhead;

                const isEditing = editingNote &&
                                  editingNote.midi === note.midi &&
                                  Math.abs(editingNote.time - note.time) < 0.001 &&
                                  editingNote.channel === note.channel;
                
                const noteKey = getNoteKey(note.midi, note.time, note.channel);
                const isFlashing = flashingNotes?.has(noteKey);

                // Deterministic random wobble
                const wobbleIdx = (note.midi + Math.floor(note.time)) % 3 + 1;

                return (
                  <div
                    key={`${note.midi}-${note.time}-${idx}`}
                    className="absolute transition-transform hover:scale-[1.02]"
                    style={{
                      left: `${left}px`,
                      top: `${top}px`,
                      width: `${width}px`,
                      height: `${NOTE_HEIGHT}px`,
                      zIndex: isEditing || isFlashing ? 50 : 10
                    }}
                    onMouseDown={(e) => handleNoteMouseDown(e, note, noteDir)}
                    onMouseUp={(e) => handleNoteMouseUp(e, shiftedMidi, noteDir)}
                    onMouseLeave={(e) => handleNoteMouseUp(e, shiftedMidi, noteDir)}
                  >
                    <HandDrawnNote
                      width={width}
                      height={NOTE_HEIGHT}
                      label={label}
                      hasMapping={hasMapping}
                      isHighlighted={!!isHighlighted}
                      isEditing={!!isEditing}
                      isFlashing={!!isFlashing}
                      mode={mode as any}
                      wobbleId={`wobble${wobbleIdx}`}
                    />
                  </div>
                );
              })}

              {/* Arrows */}
              {arrowGroups.map((group) => {
                  const items = [];
                  const dir = getDirectionAtTime(group.time);
                  const isSelected = selectedTimes.has(group.time);
                  const arrowClass = `absolute flex items-center justify-center w-6 h-6 cursor-pointer transition-transform hover:scale-125 z-20 ${isSelected ? 'text-blue-600 drop-shadow-md scale-110' : 'text-gray-800'}`;
                  const Icon = dir === Direction.PUSH ? ArrowRightIcon : ArrowLeftIcon;

                  // Render Bass Arrow
                  if (group.bassMin !== null) {
                      const shiftedMidi = group.bassMin + (octaveShift * 12) + semitoneShift;
                      const top = (MAX_MIDI - shiftedMidi) * NOTE_HEIGHT + NOTE_HEIGHT;
                      const left = group.time * PX_PER_SEC;
                      items.push(
                          <div
                              key={`arrow-bass-${group.time}`}
                              className={arrowClass}
                              style={{ left: `${left}px`, top: `${top - 4}px` }}
                              onMouseDown={(e) => e.stopPropagation()}
                              onClick={(e) => handleArrowClick(e, group.time, dir)}
                          >
                             <Icon className="w-[18px] h-[18px]" strokeWidth={3} />
                          </div>
                      );
                  }

                  // Render Treble Arrow
                  if (group.trebleMin !== null) {
                      const shiftedMidi = group.trebleMin + (octaveShift * 12) + semitoneShift;
                      const top = (MAX_MIDI - shiftedMidi) * NOTE_HEIGHT + NOTE_HEIGHT;
                      const left = group.time * PX_PER_SEC;
                      items.push(
                          <div
                              key={`arrow-treble-${group.time}`}
                              className={arrowClass}
                              style={{ left: `${left}px`, top: `${top - 4}px` }}
                              onMouseDown={(e) => e.stopPropagation()}
                              onClick={(e) => handleArrowClick(e, group.time, dir)}
                          >
                             <Icon className="w-[18px] h-[18px]" strokeWidth={3} />
                          </div>
                      );
                  }
                  
                  return <React.Fragment key={`group-${group.time}`}>{items}</React.Fragment>;
              })}
           </div>
        </div>
      </div>
    </div>
  );
};
```

components/ProjectLibrary.tsx:1-(196)
```
import React, { useState, useEffect, useRef } from 'react';
import { MidiProject } from '../types';
import { getProjectList, saveProject, loadProject, deleteProject } from '../helpers/projectStorage';
import { TrashIcon, ArrowDownTrayIcon, FolderOpenIcon, PlusIcon, ArrowPathIcon, ArrowUpOnSquareIcon } from '@heroicons/react/24/outline';

interface Props {
  player: any; // ReturnType<typeof useMidiPlayer>
}

export const ProjectLibrary: React.FC<Props> = ({ player }) => {
  const [projects, setProjects] = useState<{ id: string; name: string; lastModified: number }[]>([]);
  const [isSaving, setIsSaving] = useState(false);
  const [saveName, setSaveName] = useState('');
  const fileInputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    refreshList();
  }, []);

  // Reset Auto Save to true when a new project is loaded
  useEffect(() => {
    if (player.currentProjectId) {
      player.setIsAutoSaveEnabled(true);
    }
  }, [player.currentProjectId]);

  // Auto-Save Logic removed (moved to App.tsx)

  const refreshList = () => {
    setProjects(getProjectList().sort((a, b) => b.lastModified - a.lastModified));
  };

  const handleSave = (asNew: boolean) => {
    const state = player.getProjectState();
    if (!state) return;

    const name = saveName.trim() || player.fileName || 'Untitled Project';
    const id = (asNew || !player.currentProjectId) ? crypto.randomUUID() : player.currentProjectId;

    const project: MidiProject = {
      id,
      name: asNew ? name : (projects.find(p => p.id === id)?.name || name),
      lastModified: Date.now(),
      ...state
    };

    saveProject(project);
    if (asNew) player.loadProject(project); // Switch context to new ID
    
    setIsSaving(false);
    setSaveName('');
    refreshList();
  };

  const handleLoad = (id: string) => {
    const proj = loadProject(id);
    if (proj) {
      player.loadProject(proj);
    }
  };

  const handleDelete = (id: string, e: React.MouseEvent) => {
    e.stopPropagation();
    if (confirm('Delete this project?')) {
      deleteProject(id);
      refreshList();
    }
  };

  return (
    <div className="flex flex-col h-full">
      <h3 className="font-bold text-gray-700 mb-4 text-sm uppercase tracking-wider border-b pb-2 flex items-center gap-2">
        <FolderOpenIcon className="w-4 h-4"/>
        MIDI Projects
      </h3>

      {/* Import MIDI File */}
      <input
        type="file"
        accept=".mid,.midi"
        ref={fileInputRef}
        className="hidden"
        onChange={(e) => {
          if (e.target.files?.[0]) {
            player.loadMidiFile(e.target.files[0]);
            e.target.value = ''; // Reset
          }
        }}
      />
      <button
        onClick={() => fileInputRef.current?.click()}
        className="mb-4 w-full flex items-center justify-center gap-2 bg-gray-100 text-gray-700 text-xs font-bold py-2 rounded hover:bg-gray-200 border border-gray-200"
      >
        <ArrowUpOnSquareIcon className="w-4 h-4" />
        Import MIDI File
      </button>

      {/* Save Controls */}
      {player.fileName && (
        <div className="mb-4 p-3 bg-indigo-50 rounded border border-indigo-100">
          <div className="flex justify-between items-start mb-2">
            <div className="text-xs font-bold text-indigo-800 truncate max-w-[150px]">
              Current: {player.fileName}
            </div>
            {player.currentProjectId && (
              <label className="flex items-center gap-1 cursor-pointer">
                <input
                  type="checkbox"
                  checked={player.isAutoSaveEnabled}
                  onChange={(e) => player.setIsAutoSaveEnabled(e.target.checked)}
                  className="w-3 h-3 accent-indigo-600 rounded"
                />
                <span className="text-[10px] font-bold text-indigo-600">Auto Save</span>
              </label>
            )}
          </div>
          
          {isSaving ? (
            <div className="flex flex-col gap-2">
              <input 
                type="text" 
                placeholder="Project Name" 
                className="text-xs p-1 border rounded"
                value={saveName}
                onChange={e => setSaveName(e.target.value)}
                autoFocus
              />
              <div className="flex gap-2">
                <button onClick={() => handleSave(true)} className="flex-1 bg-indigo-600 text-white text-xs py-1 rounded hover:bg-indigo-700">
                  Save New
                </button>
                <button onClick={() => setIsSaving(false)} className="px-2 bg-gray-200 text-gray-600 text-xs rounded hover:bg-gray-300">
                  Cancel
                </button>
              </div>
            </div>
          ) : (
            <div className="flex gap-2">
              {player.currentProjectId && (
                <button 
                  onClick={() => handleSave(false)}
                  className="flex-1 flex items-center justify-center gap-1 bg-indigo-100 text-indigo-700 text-xs py-1.5 rounded hover:bg-indigo-200 border border-indigo-200"
                >
                  <ArrowPathIcon className="w-3 h-3" /> Update
                </button>
              )}
              <button 
                onClick={() => { setSaveName(player.fileName || ''); setIsSaving(true); }}
                className="flex-1 flex items-center justify-center gap-1 bg-white text-gray-700 text-xs py-1.5 rounded hover:bg-gray-50 border border-gray-300"
              >
                <PlusIcon className="w-3 h-3" /> Save As...
              </button>
            </div>
          )}
        </div>
      )}

      {/* Project List */}
      <div className="flex-1 overflow-y-auto space-y-2 min-h-0">
        {projects.length === 0 ? (
          <div className="text-center text-xs text-gray-400 italic mt-4">
            No saved projects.<br/>Load a MIDI file to start.
          </div>
        ) : (
          projects.map(p => (
            <div 
              key={p.id}
              onClick={() => handleLoad(p.id)}
              className={`group p-2 rounded border cursor-pointer transition-all hover:shadow-sm ${
                player.currentProjectId === p.id 
                  ? 'bg-blue-50 border-blue-300 ring-1 ring-blue-200' 
                  : 'bg-white border-gray-200 hover:border-blue-300'
              }`}
            >
              <div className="flex justify-between items-start">
                <div className="flex-1 min-w-0">
                  <div className="text-xs font-bold text-gray-700 truncate">{p.name}</div>
                  <div className="text-[10px] text-gray-400">
                    {new Date(p.lastModified).toLocaleDateString()} {new Date(p.lastModified).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                  </div>
                </div>
                <button 
                  onClick={(e) => handleDelete(p.id, e)}
                  className="opacity-0 group-hover:opacity-100 p-1 text-gray-400 hover:text-red-600 transition-opacity"
                  title="Delete Project"
                >
                  <TrashIcon className="w-3.5 h-3.5" />
                </button>
              </div>
            </div>
          ))
        )}
      </div>
    </div>
  );
};
```

components/SoundControls.tsx:1-(159)
```
// file: components/SoundControls.tsx
import React from 'react';
import { SoundSettings } from '../types';
import { AdjustmentsHorizontalIcon, ArrowPathIcon } from '@heroicons/react/24/outline';

interface Props {
  settings: SoundSettings;
  onUpdate: (key: keyof SoundSettings, value: number) => void;
  onReset: (key: keyof SoundSettings) => void;
  onResetAll: () => void;
}

interface ControlDef {
  key: keyof SoundSettings;
  label: string;
  min: number;
  max: number;
  step: number;
  tooltip: string;
  unit?: string;
}

const CATEGORIES: { name: string; controls: ControlDef[] }[] = [
  {
    name: "Reed Physics & Tuning",
    controls: [
      { key: "musetteDetune", label: "Musette Detune", min: 0, max: 50, step: 0.5, unit: "ct", tooltip: "Pitch difference between treble reeds (Wetness)." },
      { key: "reedAttackTime", label: "Attack Time", min: 0.001, max: 0.1, step: 0.001, unit: "s", tooltip: "How fast the reed speaks after air hits it." },
      { key: "reedReleaseTime", label: "Release Time", min: 0.05, max: 1.0, step: 0.01, unit: "s", tooltip: "Vibration inertia after button release." },
      { key: "pitchInstability", label: "Pitch Drift", min: 0, max: 10, step: 0.1, unit: "ct", tooltip: "Random organic pitch wandering." },
      { key: "bellowsPitchBend", label: "Bellows Bend", min: 0, max: 20, step: 0.5, unit: "ct", tooltip: "Pitch drop under high pressure." },
      { key: "harmonicBrightness", label: "Harmonic Brightness", min: 0.5, max: 2.5, step: 0.1, tooltip: "Waveform shape: Low=Dull, High=Buzzy." },
      { key: "bassGrowl", label: "Bass Growl", min: 0, max: 3.0, step: 0.1, tooltip: "Boosts even harmonics for Helikon rasp." },
      { key: "reedStiffness", label: "Reed Stiffness", min: 0.5, max: 2.0, step: 0.1, tooltip: "Modulates the attack curve shape." },
      { key: "trebleOctaveBalance", label: "Treble Octave Mix", min: 0, max: 1, step: 0.05, tooltip: "Balance of high octave reeds." },
      { key: "bassOctaveBalance", label: "Bass Octave Mix", min: 0, max: 1, step: 0.05, tooltip: "Balance of upper bass octave." },
    ]
  },
  {
    name: "Bellows & Air",
    controls: [
      { key: "airNoiseLevel", label: "Air Noise", min: 0, max: 0.2, step: 0.001, tooltip: "Hiss of air through valves." },
      { key: "airTurbulence", label: "Air Turbulence", min: 0, max: 1, step: 0.05, tooltip: "Random fluctuations in air noise." },
      { key: "bellowsShakeSpeed", label: "Shake Speed", min: 0, max: 15, step: 0.5, unit: "Hz", tooltip: "Vibrato speed for bellows shake." },
      { key: "bellowsShakeDepth", label: "Shake Depth", min: 0, max: 1, step: 0.05, tooltip: "Intensity of bellows shake." },
      { key: "dynamicRange", label: "Dynamic Range", min: 0, max: 1, step: 0.05, tooltip: "Volume response to pressure." },
      { key: "pushPullVariance", label: "Push/Pull Var", min: 0, max: 1, step: 0.05, tooltip: "Timbre shift between directions." },
    ]
  },
  {
    name: "Mechanics",
    controls: [
      { key: "buttonClickVolume", label: "Click Volume", min: 0, max: 1, step: 0.05, tooltip: "Volume of the button press 'clack'." },
      { key: "palletThudVolume", label: "Thud Volume", min: 0, max: 1, step: 0.05, tooltip: "Volume of the release 'thump'." },
      { key: "mechanismNoiseRandomness", label: "Mech Randomness", min: 0, max: 1, step: 0.05, tooltip: "Variance in mechanical noises." },
      { key: "bassButtonClunk", label: "Bass Clunk", min: 0, max: 1, step: 0.05, tooltip: "Heavier noise for bass buttons." },
    ]
  },
  {
    name: "Body & Resonance",
    controls: [
      { key: "boxResonanceFreq", label: "Box Freq", min: 200, max: 1000, step: 10, unit: "Hz", tooltip: "Wooden body resonant frequency." },
      { key: "boxResonanceAmount", label: "Box Amount", min: 0, max: 20, step: 0.5, unit: "dB", tooltip: "Intensity of wood resonance." },
      { key: "grilleFilterCutoff", label: "Grille Cutoff", min: 1000, max: 10000, step: 100, unit: "Hz", tooltip: "Muffling effect of the grille." },
      { key: "cassottoEffect", label: "Cassotto", min: 0, max: 1, step: 0.05, tooltip: "Tone chamber simulation (nasal/round)." },
      { key: "bassChamberResonance", label: "Bass Chamber", min: 0, max: 20, step: 0.5, unit: "dB", tooltip: "Resonance of the bass cavity." },
    ]
  },
  {
    name: "Effects & Environment",
    controls: [
      { key: "inputGain", label: "Input Drive", min: 0, max: 2.0, step: 0.05, tooltip: "Pre-amp gain. Increase to drive distortion." },
      { key: "tubeSaturation", label: "Saturation", min: 0, max: 100, step: 1, tooltip: "Harmonic distortion/warmth." },
      { key: "trebleStereoWidth", label: "Treble Width", min: 0, max: 1, step: 0.05, tooltip: "Stereo panning spread for treble." },
      { key: "bassStereoWidth", label: "Bass Width", min: 0, max: 1, step: 0.05, tooltip: "Stereo panning spread for bass." },
      { key: "reverbSize", label: "Reverb Size", min: 0.1, max: 5.0, step: 0.1, unit: "s", tooltip: "Room size/decay time." },
      { key: "reverbMix", label: "Reverb Mix", min: 0, max: 1, step: 0.05, tooltip: "Wet/Dry balance." },
      { key: "eqLow", label: "EQ Low", min: -20, max: 20, step: 1, unit: "dB", tooltip: "Bass frequencies." },
      { key: "eqMid", label: "EQ Mid", min: -20, max: 20, step: 1, unit: "dB", tooltip: "Middle frequencies." },
      { key: "eqHigh", label: "EQ High", min: -20, max: 20, step: 1, unit: "dB", tooltip: "Treble frequencies." },
    ]
  }
];

export const SoundControls: React.FC<Props> = ({ settings, onUpdate, onReset, onResetAll }) => {
  return (
    <div className="w-full bg-white border-r border-gray-200 flex flex-col shadow-xl z-30 h-full overflow-y-auto select-none">
      <div className="p-4 border-b border-gray-200 bg-gray-50 sticky top-0 z-10">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2 text-gray-800 font-bold">
            <AdjustmentsHorizontalIcon className="w-5 h-5" />
            <span>Sound Module</span>
          </div>
          <button 
            onClick={onResetAll}
            className="p-1.5 text-gray-500 hover:text-red-600 hover:bg-red-50 rounded transition-colors"
            title="Reset All to Default"
          >
            <ArrowPathIcon className="w-4 h-4" />
          </button>
        </div>
        <div className="mt-3">
           <div className="flex justify-between text-xs mb-1 text-gray-600 font-bold">
            <span>Master Volume</span>
            <span>{Math.round(settings.masterVolume * 100)}%</span>
          </div>
          <input
            type="range"
            min={0} max={1} step={0.01}
            value={settings.masterVolume}
            onChange={(e) => onUpdate("masterVolume", parseFloat(e.target.value))}
            onDoubleClick={() => onReset("masterVolume")}
            className="w-full h-2 bg-indigo-200 rounded-lg appearance-none cursor-pointer accent-indigo-600"
          />
        </div>
      </div>
      
      <div className="p-4 space-y-6">
        {CATEGORIES.map((cat) => (
          <div key={cat.name}>
            <h3 className="text-[10px] font-black text-gray-400 uppercase tracking-wider mb-3 border-b pb-1">
              {cat.name}
            </h3>
            <div className="space-y-3">
              {cat.controls.map((ctrl) => (
                <div key={ctrl.key} className="group relative">
                  <div className="flex justify-between text-[10px] mb-1 text-gray-600 font-medium items-center">
                    <div className="flex items-center gap-1 cursor-help">
                      <span>{ctrl.label}</span>
                      {/* Tooltip */}
                      <div className="absolute left-0 bottom-full mb-1 hidden group-hover:block w-48 bg-gray-800 text-white text-[10px] p-2 rounded shadow-lg z-50 pointer-events-none">
                        {ctrl.tooltip}
                      </div>
                    </div>
                    <span>{settings[ctrl.key]} {ctrl.unit}</span>
                  </div>
                  <input
                    type="range"
                    min={ctrl.min}
                    max={ctrl.max}
                    step={ctrl.step}
                    value={settings[ctrl.key]}
                    onChange={(e) => onUpdate(ctrl.key, parseFloat(e.target.value))}
                    onDoubleClick={() => onReset(ctrl.key)}
                    className="w-full h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-gray-500 hover:accent-indigo-500 transition-colors"
                  />
                </div>
              ))}
            </div>
          </div>
        ))}
      </div>
      
      <div className="mt-auto p-4 bg-gray-50 text-[10px] text-gray-400 text-center border-t">
        Double-click slider to reset.
      </div>
    </div>
  );
};
```

components/TopBar.tsx:1-(96)
```
// file: components/TopBar.tsx
import React from 'react';
import { 
  PencilSquareIcon, 
  CheckCircleIcon, 
  ArrowPathIcon, 
  SparklesIcon,
  ArrowDownTrayIcon,
  ArrowUpTrayIcon
} from '@heroicons/react/24/outline';

interface TopBarProps {
  chordName: string;
  chordDesc: string;
  isAiEnabled: boolean;
  setIsAiEnabled: (val: boolean) => void;
  isEditing: boolean;
  setIsEditing: (val: boolean) => void;
  resetLayout: () => void;
  saveLayout: () => void;
  onExportLayout: () => void;
  onImportLayout: () => void;
}

export const TopBar: React.FC<TopBarProps> = ({
  chordName,
  chordDesc,
  isAiEnabled,
  setIsAiEnabled,
  isEditing,
  setIsEditing,
  resetLayout,
  saveLayout,
  onExportLayout,
  onImportLayout
}) => {
  return (
    <div className="flex-none bg-white border-b border-gray-200 p-3 shadow-sm flex items-center justify-between z-20">
      <div className="flex items-center gap-4">
        <h1 className="text-xl font-bold text-gray-800 hidden md:block">Steirische Simulator</h1>
      </div>

      <div className="flex-1 mx-4 bg-gray-50 rounded border border-gray-200 px-3 py-1 text-center hidden sm:block flex items-center justify-center gap-4">
         <div className="flex flex-col items-center">
           <span className="font-bold text-gray-700 min-h-[1.5rem]">{chordName}</span>
           <span className="text-gray-500 text-xs">{chordDesc}</span>
         </div>
      </div>

      <div className="flex items-center gap-2">
         {/* AI Toggle Button */}
         <button 
           onClick={() => setIsAiEnabled(!isAiEnabled)}
           className={`flex items-center gap-2 px-3 py-2 rounded border transition-colors ${
             isAiEnabled 
               ? 'bg-purple-100 text-purple-700 border-purple-300 hover:bg-purple-200' 
               : 'bg-gray-50 text-gray-500 border-gray-200 hover:bg-gray-100'
           }`}
           title={isAiEnabled ? "Disable AI" : "Enable AI"}
         >
           <SparklesIcon className={`w-5 h-5 ${isAiEnabled ? 'animate-pulse' : ''}`} />
           <span className="hidden md:inline text-sm font-medium">{isAiEnabled ? 'AI On' : 'AI Off'}</span>
         </button>

         <div className="w-px h-6 bg-gray-300 mx-1"></div>

         {isEditing ? (
           <>
              {/* Import/Export Buttons (Only visible in Edit mode) */}
              <button onClick={onImportLayout} className="p-2 text-gray-600 hover:bg-gray-100 rounded" title="Import Layout (JSON)">
                <ArrowUpTrayIcon className="w-6 h-6" />
              </button>
              <button onClick={onExportLayout} className="p-2 text-gray-600 hover:bg-gray-100 rounded" title="Export Layout (JSON)">
                <ArrowDownTrayIcon className="w-6 h-6" />
              </button>

              <div className="w-px h-6 bg-gray-300 mx-1"></div>

              <button onClick={resetLayout} className="p-2 text-red-600 hover:bg-red-50 rounded" title="Reset to Default">
                <ArrowPathIcon className="w-6 h-6" />
              </button>
              <button onClick={saveLayout} className="flex items-center gap-2 px-3 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700">
                <CheckCircleIcon className="w-5 h-5" />
                <span>Done</span>
              </button>
           </>
         ) : (
           <button onClick={() => setIsEditing(true)} className="flex items-center gap-2 px-3 py-2 text-gray-600 hover:bg-gray-100 rounded">
             <PencilSquareIcon className="w-5 h-5" />
             <span className="hidden md:inline">Layout</span>
           </button>
         )}
      </div>
    </div>
  );
};
```

constants.ts:1-(215)
```
// file: constants.ts
import { NoteDefinition } from './types';

interface ButtonDef {
  push: NoteDefinition;
  pull: NoteDefinition;
}

interface RowDef {
  rowId: number;
  buttons: ButtonDef[];
}

export const BASS_ROWS: RowDef[] = [
  {
    rowId: 0,
    buttons: [
      // bass-0-0: Bass Note -> Push: C#2 (MIDI 37), Pull: G#2 (MIDI 44)
      { 
        push: { midi: 37, label: "C#2 (des)", type: "bass" }, 
        pull: { midi: 44, label: "G#2 (as)", type: "bass" } 
      },
      // bass-0-1: Chord -> Push: C#3 Major, Pull: G#3 Major
      { 
        push: { midi: 49, label: "C#3 Major (Des)", type: "chord", chordType: "major" }, 
        pull: { midi: 56, label: "G#3 Major (As)", type: "chord", chordType: "major" } 
      },
      // bass-0-2: Bass Note -> Push: G#2 (MIDI 44), Pull: D#2 (MIDI 39)
      { 
        push: { midi: 44, label: "G#2 (as)", type: "bass" }, 
        pull: { midi: 39, label: "D#2 (es)", type: "bass" } 
      },
      // bass-0-3: Chord -> Push: G#3 Major, Pull: D#3 Major
      { 
        push: { midi: 56, label: "G#3 Major (As)", type: "chord", chordType: "major" }, 
        pull: { midi: 51, label: "D#3 Major (Es)", type: "chord", chordType: "major" } 
      },
      // bass-0-4: Bass Note -> Push: D#2 (MIDI 39), Pull: A#2 (MIDI 46)
      { 
        push: { midi: 39, label: "D#2 (es)", type: "bass" }, 
        pull: { midi: 46, label: "A#2 (b)", type: "bass" } 
      },
      // bass-0-5: Chord -> Push: D#3 Major, Pull: A#2 Major
      { 
        push: { midi: 51, label: "D#3 Major (Es)", type: "chord", chordType: "major" }, 
        pull: { midi: 46, label: "A#2 Major (B)", type: "chord", chordType: "major" } 
      },
      // bass-0-6: Bass Note -> Push: A#2 (MIDI 46), Pull: F2 (MIDI 41)
      { 
        push: { midi: 46, label: "A#2 (b)", type: "bass" }, 
        pull: { midi: 41, label: "F2 (f)", type: "bass" } 
      },
      // bass-0-7: Chord -> Push: A#2 Major, Pull: F3 Major
      { 
        push: { midi: 46, label: "A#2 Major (B)", type: "chord", chordType: "major" }, 
        pull: { midi: 53, label: "F3 Major (F)", type: "chord", chordType: "major" } 
      },
    ]
  },
  {
    rowId: 1,
    buttons: [
      // bass-1-0: Bass Note -> Push: F2 (MIDI 41), Pull: F#2 (MIDI 42)
      { 
        push: { midi: 41, label: "F2 (f)", type: "bass" }, 
        pull: { midi: 42, label: "F#2 (ges)", type: "bass" } 
      },
      // bass-1-1: Chord -> Push: F3 Major, Pull: F#3 Major
      { 
        push: { midi: 53, label: "F3 Major (F)", type: "chord", chordType: "major" }, 
        pull: { midi: 54, label: "F#3 Major (Ges)", type: "chord", chordType: "major" } 
      },
      // bass-1-2: Bass Note -> Push: C2 (MIDI 36), Pull: C#2 (MIDI 37)
      { 
        push: { midi: 36, label: "C2 (c)", type: "bass" }, 
        pull: { midi: 37, label: "C#2 (des)", type: "bass" } 
      },
      // bass-1-3: Chord -> Push: C3 Major, Pull: C#3 Major
      { 
        push: { midi: 48, label: "C3 Major (C)", type: "chord", chordType: "major" }, 
        pull: { midi: 49, label: "C#3 Major (Des)", type: "chord", chordType: "major" } 
      },
      // bass-1-4: Bass Note -> Push: G2 (MIDI 43), Pull: G#2 (MIDI 44)
      { 
        push: { midi: 43, label: "G2 (g)", type: "bass" }, 
        pull: { midi: 44, label: "G#2 (as)", type: "bass" } 
      },
      // bass-1-5: Chord -> Push: G3 Major, Pull: A#2 Major
      { 
        push: { midi: 55, label: "G3 Major (G)", type: "chord", chordType: "major" }, 
        pull: { midi: 46, label: "A#2 Major (B)", type: "chord", chordType: "major" } 
      },
      // bass-1-6: Bass Note -> Push: C#2 (MIDI 37), Pull: C2 (MIDI 36)
      { 
        push: { midi: 37, label: "C#2 (des)", type: "bass" }, 
        pull: { midi: 36, label: "C2 (c)", type: "bass" } 
      },
    ]
  }
];

export const TREBLE_ROWS: RowDef[] = [
  {
    rowId: 0,
    buttons: [
      // treble-0-0: Push: C#7 (des''''), Pull: A#6 (b''')
      { push: { midi: 97, label: "C#7 (des'''')", type: "treble" }, pull: { midi: 94, label: "A#6 (b''')", type: "treble" } },
      // treble-0-1: Push: G#6 (as'''), Pull: F#6 (ges''')
      { push: { midi: 92, label: "G#6 (as''')", type: "treble" }, pull: { midi: 90, label: "F#6 (ges''')", type: "treble" } },
      // treble-0-2: Push: F6 (f'''), Pull: D#6 (es''')
      { push: { midi: 89, label: "F6 (f''')", type: "treble" }, pull: { midi: 87, label: "D#6 (es''')", type: "treble" } },
      // treble-0-3: Push: C#6 (des'''), Pull: C6 (c''')
      { push: { midi: 85, label: "C#6 (des''')", type: "treble" }, pull: { midi: 84, label: "C6 (c''')", type: "treble" } },
      // treble-0-4: Push: G#5 (as''), Pull: G#5 (as'')
      { push: { midi: 80, label: "G#5 (as'')", type: "treble" }, pull: { midi: 80, label: "G#5 (as'')", type: "treble" } },
      // treble-0-5: Push: F5 (f''), Pull: F#5 (ges'')
      { push: { midi: 77, label: "F5 (f'')", type: "treble" }, pull: { midi: 78, label: "F#5 (ges'')", type: "treble" } },
      // treble-0-6: Push: C#5 (des''), Pull: D#5 (es'')
      { push: { midi: 73, label: "C#5 (des'')", type: "treble" }, pull: { midi: 75, label: "D#5 (es'')", type: "treble" } },
      // treble-0-7: Push: G#4 (as'), Pull: C5 (c'')
      { push: { midi: 68, label: "G#4 (as')", type: "treble" }, pull: { midi: 72, label: "C5 (c'')", type: "treble" } },
      // treble-0-8: Push: F4 (f'), Pull: G#4 (as')
      { push: { midi: 65, label: "F4 (f')", type: "treble" }, pull: { midi: 68, label: "G#4 (as')", type: "treble" } },
      // treble-0-9: Push: C#4 (des'), Pull: F#4 (ges')
      { push: { midi: 61, label: "C#4 (des')", type: "treble" }, pull: { midi: 66, label: "F#4 (ges')", type: "treble" } },
    ]
  },
  {
    rowId: 1,
    buttons: [
      // treble-1-0: Push: C7 (c''''), Pull: G6 (g''')
      { push: { midi: 96, label: "C7 (c'''')", type: "treble" }, pull: { midi: 91, label: "G6 (g''')", type: "treble" } },
      // treble-1-1: Push: G#6 (as'''), Pull: F6 (f''')
      { push: { midi: 92, label: "G#6 (as''')", type: "treble" }, pull: { midi: 89, label: "F6 (f''')", type: "treble" } },
      // treble-1-2: Push: D#6 (es'''), Pull: C#6 (des''')
      { push: { midi: 87, label: "D#6 (es''')", type: "treble" }, pull: { midi: 85, label: "C#6 (des''')", type: "treble" } },
      // treble-1-3: Push: C6 (c'''), Pull: A#5 (b'')
      { push: { midi: 84, label: "C6 (c''')", type: "treble" }, pull: { midi: 82, label: "A#5 (b'')", type: "treble" } },
      // treble-1-4: Push: G#5 (as''), Pull: G5 (g'')
      { push: { midi: 80, label: "G#5 (as'')", type: "treble" }, pull: { midi: 79, label: "G5 (g'')", type: "treble" } },
      // treble-1-5: Push: D#5 (es''), Pull: D#5 (es'')
      { push: { midi: 75, label: "D#5 (es'')", type: "treble" }, pull: { midi: 75, label: "D#5 (es'')", type: "treble" } },
      // treble-1-6: Push: C5 (c''), Pull: C#5 (des'')
      { push: { midi: 72, label: "C5 (c'')", type: "treble" }, pull: { midi: 73, label: "C#5 (des'')", type: "treble" } },
      // treble-1-7: Push: G#4 (as'), Pull: A#4 (b')
      { push: { midi: 68, label: "G#4 (as')", type: "treble" }, pull: { midi: 70, label: "A#4 (b')", type: "treble" } },
      // treble-1-8: Push: D#4 (es'), Pull: G4 (g')
      { push: { midi: 63, label: "D#4 (es')", type: "treble" }, pull: { midi: 67, label: "G4 (g')", type: "treble" } },
      // treble-1-9: Push: C4 (c'), Pull: D#4 (es')
      { push: { midi: 60, label: "C4 (c')", type: "treble" }, pull: { midi: 63, label: "D#4 (es')", type: "treble" } },
      // treble-1-10: Push: G#3 (as), Pull: C#4 (des')
      { push: { midi: 56, label: "G#3 (as)", type: "treble" }, pull: { midi: 61, label: "C#4 (des')", type: "treble" } },
    ]
  },
  {
    rowId: 2,
    buttons: [
      // treble-2-0: Push: A#6 (b'''), Pull: F6 (f''')
      { push: { midi: 94, label: "A#6 (b''')", type: "treble" }, pull: { midi: 89, label: "F6 (f''')", type: "treble" } },
      // treble-2-1: Push: G6 (g'''), Pull: D6 (d''')
      { push: { midi: 91, label: "G6 (g''')", type: "treble" }, pull: { midi: 86, label: "D6 (d''')", type: "treble" } },
      // treble-2-2: Push: D#6 (es'''), Pull: C6 (c''')
      { push: { midi: 87, label: "D#6 (es''')", type: "treble" }, pull: { midi: 84, label: "C6 (c''')", type: "treble" } },
      // treble-2-3: Push: A#5 (b''), Pull: G#5 (as'')
      { push: { midi: 82, label: "A#5 (b'')", type: "treble" }, pull: { midi: 80, label: "G#5 (as'')", type: "treble" } },
      // treble-2-4: Push: G5 (g''), Pull: F5 (f'')
      { push: { midi: 79, label: "G5 (g'')", type: "treble" }, pull: { midi: 77, label: "F5 (f'')", type: "treble" } },
      // treble-2-5: Push: D#5 (es''), Pull: D5 (d'')
      { push: { midi: 75, label: "D#5 (es'')", type: "treble" }, pull: { midi: 74, label: "D5 (d'')", type: "treble" } },
      // treble-2-6: Push: A#4 (b'), Pull: A#4 (b')
      { push: { midi: 70, label: "A#4 (b')", type: "treble" }, pull: { midi: 70, label: "A#4 (b')", type: "treble" } },
      // treble-2-7: Push: G4 (g'), Pull: G#4 (as')
      { push: { midi: 67, label: "G4 (g')", type: "treble" }, pull: { midi: 68, label: "G#4 (as')", type: "treble" } },
      // treble-2-8: Push: D#4 (es'), Pull: F4 (f')
      { push: { midi: 63, label: "D#4 (es')", type: "treble" }, pull: { midi: 65, label: "F4 (f')", type: "treble" } },
      // treble-2-9: Push: A#3 (b), Pull: D4 (d')
      { push: { midi: 58, label: "A#3 (b)", type: "treble" }, pull: { midi: 62, label: "D4 (d')", type: "treble" } },
      // treble-2-10: Push: G3 (g), Pull: A#3 (b)
      { push: { midi: 55, label: "G3 (g)", type: "treble" }, pull: { midi: 58, label: "A#3 (b)", type: "treble" } },
      // treble-2-11: Push: D#3 (es), Pull: G#3 (as)
      { push: { midi: 51, label: "D#3 (es)", type: "treble" }, pull: { midi: 56, label: "G#3 (as)", type: "treble" } },
    ]
  },
  {
    rowId: 3,
    buttons: [
      // treble-3-0: Push: A#6 (b'''), Pull: D#6 (es''')
      { push: { midi: 94, label: "A#6 (b''')", type: "treble" }, pull: { midi: 87, label: "D#6 (es''')", type: "treble" } },
      // treble-3-1: Push: F6 (f'''), Pull: C6 (c''')
      { push: { midi: 89, label: "F6 (f''')", type: "treble" }, pull: { midi: 84, label: "C6 (c''')", type: "treble" } },
      // treble-3-2: Push: D6 (d'''), Pull: A5 (a'')
      { push: { midi: 86, label: "D6 (d''')", type: "treble" }, pull: { midi: 81, label: "A5 (a'')", type: "treble" } },
      // treble-3-3: Push: A#5 (b''), Pull: G5 (g'')
      { push: { midi: 82, label: "A#5 (b'')", type: "treble" }, pull: { midi: 79, label: "G5 (g'')", type: "treble" } },
      // treble-3-4: Push: F5 (f''), Pull: D#5 (es'')
      { push: { midi: 77, label: "F5 (f'')", type: "treble" }, pull: { midi: 75, label: "D#5 (es'')", type: "treble" } },
      // treble-3-5: Push: D5 (d''), Pull: C5 (c'')
      { push: { midi: 74, label: "D5 (d'')", type: "treble" }, pull: { midi: 72, label: "C5 (c'')", type: "treble" } },
      // treble-3-6: Push: A#4 (b'), Pull: A4 (a')
      { push: { midi: 70, label: "A#4 (b')", type: "treble" }, pull: { midi: 69, label: "A4 (a')", type: "treble" } },
      // treble-3-7: Push: F4 (f'), Pull: G4 (g')
      { push: { midi: 65, label: "F4 (f')", type: "treble" }, pull: { midi: 67, label: "G4 (g')", type: "treble" } },
      // treble-3-8: Push: D4 (d'), Pull: D#4 (es')
      { push: { midi: 62, label: "D4 (d')", type: "treble" }, pull: { midi: 63, label: "D#4 (es')", type: "treble" } },
      // treble-3-9: Push: A#3 (b), Pull: C4 (c')
      { push: { midi: 58, label: "A#3 (b)", type: "treble" }, pull: { midi: 60, label: "C4 (c')", type: "treble" } },
      // treble-3-10: Push: F3 (f), Pull: A3 (a)
      { push: { midi: 53, label: "F3 (f)", type: "treble" }, pull: { midi: 57, label: "A3 (a)", type: "treble" } },
      // treble-3-11: Push: D3 (d), Pull: F3 (f)
      { push: { midi: 50, label: "D3 (d)", type: "treble" }, pull: { midi: 53, label: "F3 (f)", type: "treble" } },
      // treble-3-12: Push: A#2 (B), Pull: D#3 (es)
      { push: { midi: 46, label: "A#2 (B)", type: "treble" }, pull: { midi: 51, label: "D#3 (es)", type: "treble" } },
    ]
  }
];
```

dist_apk/Steirische-v1.1-20260102-2341.apk:1-(1)
```
# [binary file omitted]
```

dist_apk/Steirische-v1.1-20260102-2352.apk:1-(1)
```
# [binary file omitted]
```

dist_apk/Steirische-v1.1-20260102-235844.apk:1-(1)
```
# [binary file omitted]
```

dist_apk/Steirische-v1.1-20260103-000653.apk:1-(1)
```
# [binary file omitted]
```

dist_apk/Steirische-v1.1-20260104-125535.apk:1-(1)
```
# [binary file omitted]
```

helpers/appConfig.ts:1-(30)
```
// file: helpers/appConfig.ts
import { SoundSettings } from '../types';

export const STORAGE_KEY_LAYOUT = 'steirische_layout_v1';
export const STORAGE_KEY_SOUND = 'steirische_sound_v1';
export const FILENAME = 'accordion_line_drawing.png';

// Paths to try sequentially if one fails
export const CANDIDATE_PATHS = [
  `assets/${FILENAME}`,      // Standard relative
  `./assets/${FILENAME}`,    // Explicit relative
  `/assets/${FILENAME}`,     // Absolute from root
  `${FILENAME}`,             // Root (if flattened)
  `/${FILENAME}`,            // Absolute root
  `../assets/${FILENAME}`    // Parent relative
];

export const DEFAULT_SOUND_SETTINGS: SoundSettings = {
  musetteDetune: 14, reedAttackTime: 0.03, reedReleaseTime: 0.15, pitchInstability: 2, bellowsPitchBend: 0,
  harmonicBrightness: 1.0, bassGrowl: 1.0, reedStiffness: 1.0, trebleOctaveBalance: 0.5, bassOctaveBalance: 0.5,
  airNoiseLevel: 0.03, airTurbulence: 0.5, bellowsShakeSpeed: 5, bellowsShakeDepth: 0, dynamicRange: 1.0, pushPullVariance: 0,
  buttonClickVolume: 0.4, palletThudVolume: 0.3, mechanismNoiseRandomness: 0.2, bassButtonClunk: 0.5,
  boxResonanceFreq: 400, boxResonanceAmount: 4, grilleFilterCutoff: 5000, cassottoEffect: 0, bassChamberResonance: 2,
  tubeSaturation: 0, inputGain: 0.5, trebleStereoWidth: 0.3, bassStereoWidth: 0.1, reverbSize: 1.5, reverbMix: 0.1,
  eqLow: 0, eqMid: 0, eqHigh: 0, masterVolume: 0.4
};

// Layout Split Constants (Percentages of original image width)
export const SPLIT_LEFT_LIMIT = 21.5; // Bass section ends at 21.5%
export const SPLIT_RIGHT_START = 76.0; // Treble section starts at 76.0%
```

helpers/layout_apk.json:1-(246)
```
{
  "bass-0-0": {
    "left": 8.504272967766413,
    "top": 15.092592831665268
  },
  "bass-0-1": {
    "left": 8.65384610055074,
    "top": 24.293981741403528
  },
  "bass-0-2": {
    "left": 8.219526001908024,
    "top": 33.95833480946813
  },
  "bass-0-3": {
    "left": 8.595084930025351,
    "top": 43.287037342827674
  },
  "bass-0-4": {
    "left": 8.044871357849459,
    "top": 54.00462859828122
  },
  "bass-0-5": {
    "left": 8.493589370521894,
    "top": 62.73147945214363
  },
  "bass-0-6": {
    "left": 8.376068415151671,
    "top": 71.79398234186512
  },
  "bass-0-7": {
    "left": 9.054486539942289,
    "top": 81.16898346773064
  },
  "bass-1-0": {
    "left": 15.032051346005762,
    "top": 19.062500487875067
  },
  "bass-1-1": {
    "left": 15.251067860879452,
    "top": 29.247686451436408
  },
  "bass-1-2": {
    "left": 15.005341660054198,
    "top": 39.097223381446724
  },
  "bass-1-3": {
    "left": 15.074785734983818,
    "top": 48.11342767866225
  },
  "bass-1-4": {
    "left": 15.491452955922721,
    "top": 56.97916530311843
  },
  "bass-1-5": {
    "left": 14.877136414599171,
    "top": 67.8240724339243
  },
  "bass-1-6": {
    "left": 14.88782001184368,
    "top": 76.41203651719294
  },
  "treble-0-0": {
    "left": 77.30234707684586,
    "top": 14.027778494995815
  },
  "treble-0-1": {
    "left": 77.74305592507044,
    "top": 21.445408692997507
  },
  "treble-0-2": {
    "left": 78.09428455399609,
    "top": 28.799199244930605
  },
  "treble-0-3": {
    "left": 77.43189140936802,
    "top": 36.24069780342351
  },
  "treble-0-4": {
    "left": 77.84722259173711,
    "top": 44.097058130744465
  },
  "treble-0-5": {
    "left": 78.0422012206627,
    "top": 51.844367203976
  },
  "treble-0-6": {
    "left": 77.95138925840378,
    "top": 59.503968270647746
  },
  "treble-0-7": {
    "left": 78.04220122066269,
    "top": 67.57843110614753
  },
  "treble-0-8": {
    "left": 78.18509651625497,
    "top": 75.32574017937907
  },
  "treble-0-9": {
    "left": 78.27590847851391,
    "top": 82.87628999196137
  },
  "treble-1-0": {
    "left": 82.90464772369268,
    "top": 10.424226980642034
  },
  "treble-1-1": {
    "left": 83.1517096859516,
    "top": 18.062484799784144
  },
  "treble-1-2": {
    "left": 83.48958361046944,
    "top": 25.503983358277043
  },
  "treble-1-3": {
    "left": 83.45085498154388,
    "top": 33.03318992332973
  },
  "treble-1-4": {
    "left": 83.63247890606175,
    "top": 40.80184224409089
  },
  "treble-1-5": {
    "left": 83.59375027713617,
    "top": 48.549151317322426
  },
  "treble-1-6": {
    "left": 83.73664557272843,
    "top": 56.099701129904744
  },
  "treble-1-7": {
    "left": 83.68456223939509,
    "top": 63.9560614572257
  },
  "treble-1-8": {
    "left": 83.6845622393951,
    "top": 71.61566252389743
  },
  "treble-1-9": {
    "left": 83.6845622393951,
    "top": 79.58107410530779
  },
  "treble-1-10": {
    "left": 83.69791694380285,
    "top": 87.43743443262875
  },
  "treble-2-0": {
    "left": 88.29994678016615,
    "top": 7.32577035463768
  },
  "treble-2-1": {
    "left": 88.62446600027627,
    "top": 14.658217659041155
  },
  "treble-2-2": {
    "left": 88.74198737135067,
    "top": 22.09971621753405
  },
  "treble-2-3": {
    "left": 88.97569462920188,
    "top": 29.650266030116356
  },
  "treble-2-4": {
    "left": 89.17067325812747,
    "top": 37.3975751033479
  },
  "treble-2-5": {
    "left": 89.07986129586855,
    "top": 44.94812491593022
  },
  "treble-2-6": {
    "left": 89.22275659146082,
    "top": 52.804485243251165
  },
  "treble-2-7": {
    "left": 89.36565188705309,
    "top": 60.24598380174407
  },
  "treble-2-8": {
    "left": 89.46981855371975,
    "top": 68.21139538315444
  },
  "treble-2-9": {
    "left": 89.41773522038645,
    "top": 75.76194519573676
  },
  "treble-2-10": {
    "left": 89.52190188705309,
    "top": 83.6183055230577
  },
  "treble-2-11": {
    "left": 89.56063051597869,
    "top": 91.36561459628922
  },
  "treble-3-0": {
    "left": 94.35897197134014,
    "top": 3.8425925314344656
  },
  "treble-3-1": {
    "left": 94.56597231460091,
    "top": 11.472053026476997
  },
  "treble-3-2": {
    "left": 94.76095094352658,
    "top": 18.913551584969888
  },
  "treble-3-3": {
    "left": 94.9038462391188,
    "top": 26.245998889373375
  },
  "treble-3-4": {
    "left": 95.15090820137773,
    "top": 33.88425670851549
  },
  "treble-3-5": {
    "left": 95.34588683030337,
    "top": 41.65290902927665
  },
  "treble-3-6": {
    "left": 95.30715820137776,
    "top": 49.09440758776954
  },
  "treble-3-7": {
    "left": 95.50213683030346,
    "top": 56.84171666100108
  },
  "treble-3-8": {
    "left": 95.68376075482128,
    "top": 64.69807698832203
  },
  "treble-3-9": {
    "left": 95.54086545922897,
    "top": 72.24862680090433
  },
  "treble-3-10": {
    "left": 95.69711545922905,
    "top": 79.99593587413587
  },
  "treble-3-11": {
    "left": 95.60630349697003,
    "top": 88.07039870963565
  },
  "treble-3-12": {
    "left": 95.60630349697003,
    "top": 95.81770778286719
  }
}
```

helpers/layout.json:1-(246)
```
{
  "bass-0-0": {
    "left": 7.968749999999999,
    "top": 20.828789531079607
  },
  "bass-0-1": {
    "left": 8.030833333333291,
    "top": 27.91087241003271
  },
  "bass-0-2": {
    "left": 7.656249999999997,
    "top": 35.00545256270448
  },
  "bass-0-3": {
    "left": 7.916666666666666,
    "top": 42.093784078516904
  },
  "bass-0-4": {
    "left": 7.812499999999999,
    "top": 50.05452562704471
  },
  "bass-0-5": {
    "left": 7.968749999999999,
    "top": 56.706652126499456
  },
  "bass-0-6": {
    "left": 8.072916666666664,
    "top": 63.467829880043624
  },
  "bass-0-7": {
    "left": 8.4375,
    "top": 70.44711014176663
  },
  "bass-1-0": {
    "left": 12.968750000000002,
    "top": 23.882224645583424
  },
  "bass-1-1": {
    "left": 12.916666666666668,
    "top": 31.406761177753545
  },
  "bass-1-2": {
    "left": 13.177083333333334,
    "top": 38.93129770992366
  },
  "bass-1-3": {
    "left": 12.96875,
    "top": 45.69247546346783
  },
  "bass-1-4": {
    "left": 13.229166666666666,
    "top": 52.23555070883316
  },
  "bass-1-5": {
    "left": 12.708333333333336,
    "top": 60.414394765539804
  },
  "bass-1-6": {
    "left": 12.760416666666666,
    "top": 66.8484187568157
  },
  "treble-0-0": {
    "left": 86.97916666666667,
    "top": 22.573609596510362
  },
  "treble-0-1": {
    "left": 87.18750000000001,
    "top": 28.135223555070883
  },
  "treble-0-2": {
    "left": 87.44791666666673,
    "top": 33.914940021810246
  },
  "treble-0-3": {
    "left": 87.23958333333334,
    "top": 39.585605234460196
  },
  "treble-0-4": {
    "left": 87.29166666666669,
    "top": 45.474372955288985
  },
  "treble-0-5": {
    "left": 87.39583333333334,
    "top": 51.25408942202835
  },
  "treble-0-6": {
    "left": 87.39583333333334,
    "top": 57.14285714285714
  },
  "treble-0-7": {
    "left": 87.39583333333333,
    "top": 63.24972737186477
  },
  "treble-0-8": {
    "left": 87.44791666666667,
    "top": 69.02944383860415
  },
  "treble-0-9": {
    "left": 87.44791666666667,
    "top": 74.80916030534351
  },
  "treble-1-0": {
    "left": 90.26041666666667,
    "top": 20.065430752453654
  },
  "treble-1-1": {
    "left": 90.41666666666667,
    "top": 25.7360959651036
  },
  "treble-1-2": {
    "left": 90.57291666666666,
    "top": 31.40676117775355
  },
  "treble-1-3": {
    "left": 90.625,
    "top": 36.968375136314066
  },
  "treble-1-4": {
    "left": 90.62499999999999,
    "top": 42.96619411123228
  },
  "treble-1-5": {
    "left": 90.67708333333334,
    "top": 48.74591057797164
  },
  "treble-1-6": {
    "left": 90.72916666666667,
    "top": 54.52562704471101
  },
  "treble-1-7": {
    "left": 90.67708333333333,
    "top": 60.414394765539804
  },
  "treble-1-8": {
    "left": 90.67708333333336,
    "top": 66.30316248636859
  },
  "treble-1-9": {
    "left": 90.67708333333334,
    "top": 72.3009814612868
  },
  "treble-1-10": {
    "left": 90.78125000000003,
    "top": 78.18974918211559
  },
  "treble-2-0": {
    "left": 93.38541666666669,
    "top": 17.557251908396946
  },
  "treble-2-1": {
    "left": 93.4375,
    "top": 23.118865866957474
  },
  "treble-2-2": {
    "left": 93.64583333333334,
    "top": 28.789531079607418
  },
  "treble-2-3": {
    "left": 93.69791666666667,
    "top": 34.56924754634678
  },
  "treble-2-4": {
    "left": 93.80208333333333,
    "top": 40.34896401308615
  },
  "treble-2-5": {
    "left": 93.80208333333334,
    "top": 46.12868047982552
  },
  "treble-2-6": {
    "left": 93.85416666666667,
    "top": 52.0174482006543
  },
  "treble-2-7": {
    "left": 93.90625,
    "top": 57.68811341330426
  },
  "treble-2-8": {
    "left": 94.01041666666666,
    "top": 63.68593238822247
  },
  "treble-2-9": {
    "left": 93.95833333333336,
    "top": 69.46564885496184
  },
  "treble-2-10": {
    "left": 94.0625,
    "top": 75.35441657579062
  },
  "treble-2-11": {
    "left": 94.01041666666666,
    "top": 81.13413304252998
  },
  "treble-3-0": {
    "left": 96.77083333333333,
    "top": 15.04907306434024
  },
  "treble-3-1": {
    "left": 96.92708333333334,
    "top": 20.719738276990185
  },
  "treble-3-2": {
    "left": 97.03125000000003,
    "top": 26.39040348964013
  },
  "treble-3-3": {
    "left": 97.08333333333333,
    "top": 31.952017448200657
  },
  "treble-3-4": {
    "left": 97.23958333333331,
    "top": 37.6226826608506
  },
  "treble-3-5": {
    "left": 97.34375000000001,
    "top": 43.62050163576881
  },
  "treble-3-6": {
    "left": 97.39583333333334,
    "top": 49.291166848418754
  },
  "treble-3-7": {
    "left": 97.5000000000001,
    "top": 55.07088331515813
  },
  "treble-3-8": {
    "left": 97.50000000000004,
    "top": 60.95965103598691
  },
  "treble-3-9": {
    "left": 97.44791666666667,
    "top": 66.73936750272628
  },
  "treble-3-10": {
    "left": 97.60416666666676,
    "top": 72.51908396946565
  },
  "treble-3-11": {
    "left": 97.60416666666667,
    "top": 78.62595419847328
  },
  "treble-3-12": {
    "left": 97.60416666666667,
    "top": 84.40567066521265
  }
}
```

helpers/layoutGenerator.ts:1-(23)
```
// file: helpers/layoutGenerator.ts
import { Capacitor } from '@capacitor/core';
import { LayoutMap } from '../types';
import defaultLayoutJson from './layout.json';

// Load layout from the JSON file, with Android override support
export const generateDefaultLayout = async (): Promise<LayoutMap> => {
  const isAndroid = Capacitor.getPlatform() === 'android';

  if (isAndroid) {
    // Use Vite's glob import to safely check for the file without build errors if missing
    const modules = import.meta.glob('./layout_apk.json', { eager: true });
    const apkModule = modules['./layout_apk.json'] as any;

    if (apkModule && apkModule.default) {
      console.log("Loaded Android-specific layout (layout_apk.json)");
      return apkModule.default as LayoutMap;
    }
  }

  return defaultLayoutJson as LayoutMap;
};
```

helpers/midiMap.ts:1-(53)
```
import { BASS_ROWS, TREBLE_ROWS } from '../constants';
import { Direction } from '../types';

// Change: Map to string[] instead of string
type NoteMap = Map<number, string[]>; 

let pushMap: NoteMap | null = null;
let pullMap: NoteMap | null = null;

export const getButtonIdsForNote = (midi: number, direction: Direction): string[] => {
  if (!pushMap || !pullMap) buildMaps();
  
  const map = direction === Direction.PUSH ? pushMap : pullMap;
  return map?.get(midi) || [];
};

// Keep the singular version for backward compatibility if needed, or just use the first one
export const getButtonIdForNote = (midi: number, direction: Direction): string | undefined => {
  const ids = getButtonIdsForNote(midi, direction);
  return ids.length > 0 ? ids[0] : undefined;
};

const buildMaps = () => {
  pushMap = new Map();
  pullMap = new Map();

  const processRows = (rows: any[], prefix: string) => {
    rows.forEach((row, rIdx) => {
      row.buttons.forEach((btn: any, bIdx: number) => {
        const id = `${prefix}-${rIdx}-${bIdx}`;
        
        // Map Push
        if (!pushMap!.has(btn.push.midi)) {
          pushMap!.set(btn.push.midi, []);
        }
        pushMap!.get(btn.push.midi)!.push(id);

        // Map Pull
        if (!pullMap!.has(btn.pull.midi)) {
          pullMap!.set(btn.pull.midi, []);
        }
        pullMap!.get(btn.pull.midi)!.push(id);
      });
    });
  };

  processRows(BASS_ROWS, 'bass');
  processRows(TREBLE_ROWS, 'treble');
};

export const getNoteKey = (midi: number, time: number, channel: number) => {
  return `${midi}-${time.toFixed(3)}-${channel}`;
};
```

helpers/projectStorage.ts:1-(56)
```
import { MidiProject } from '../types';

const STORAGE_PREFIX = 'steirische_proj_';
const INDEX_KEY = 'steirische_proj_index';

export const getProjectList = (): { id: string; name: string; lastModified: number }[] => {
  try {
    const index = localStorage.getItem(INDEX_KEY);
    return index ? JSON.parse(index) : [];
  } catch (e) {
    console.error("Failed to load project index", e);
    return [];
  }
};

export const loadProject = (id: string): MidiProject | null => {
  try {
    const data = localStorage.getItem(STORAGE_PREFIX + id);
    return data ? JSON.parse(data) : null;
  } catch (e) {
    console.error("Failed to load project", id, e);
    return null;
  }
};

export const saveProject = (project: MidiProject): void => {
  try {
    // 1. Save Project Data
    localStorage.setItem(STORAGE_PREFIX + project.id, JSON.stringify(project));

    // 2. Update Index
    const list = getProjectList();
    const existingIdx = list.findIndex(p => p.id === project.id);
    const meta = { id: project.id, name: project.name, lastModified: project.lastModified };
    
    if (existingIdx >= 0) {
      list[existingIdx] = meta;
    } else {
      list.push(meta);
    }
    localStorage.setItem(INDEX_KEY, JSON.stringify(list));
  } catch (e) {
    console.error("Failed to save project", e);
    alert("Storage full or error saving project.");
  }
};

export const deleteProject = (id: string): void => {
  try {
    localStorage.removeItem(STORAGE_PREFIX + id);
    const list = getProjectList().filter(p => p.id !== id);
    localStorage.setItem(INDEX_KEY, JSON.stringify(list));
  } catch (e) {
    console.error("Failed to delete project", e);
  }
};
```

hooks/useAudioController.ts:1-(99)
```
import { useState, useEffect } from 'react';
import { Direction, NoteDefinition } from '../types';
import { audioService } from '../services/audioService';
import { analyzeChord } from '../services/geminiService';

export const useAudioController = (isEditing: boolean) => {
  const [direction, setDirection] = useState<Direction>(Direction.PUSH);
  const [activeNotes, setActiveNotes] = useState<Set<string>>(new Set());
  
  // AI State
  const [isAiEnabled, setIsAiEnabled] = useState(false);
  const [chordName, setChordName] = useState<string>('');
  const [chordDesc, setChordDesc] = useState<string>('AI analysis is disabled');

  const handleNoteStart = (
    id: string,
    noteDef: NoteDefinition,
    type: 'bass' | 'chord' | 'treble',
    chordType?: any,
    newDirection?: Direction,
    options?: { silent?: boolean; duration?: number }
  ) => {
    if (isEditing) return;
    
    if (newDirection) {
      setDirection(newDirection);
    }

    // Only play audio if not silent
    if (!options?.silent) {
      audioService.playNote(id, noteDef.midi, type, chordType, newDirection || direction, { duration: options?.duration });
    }
    
    setActiveNotes(prev => {
      const next = new Set(prev);
      next.add(id);
      return next;
    });
  };

  const handleNoteStop = (id: string) => {
    audioService.stopNote(id);
    setActiveNotes(prev => {
      const next = new Set(prev);
      next.delete(id);
      return next;
    });
  };

  const stopAllNotes = () => {
    audioService.stopAll();
    setActiveNotes(new Set());
  };

  // AI Analysis Effect
  useEffect(() => {
    if (!isAiEnabled) {
      setChordName('');
      setChordDesc('AI analysis is disabled');
      return;
    }

    const timeoutId = setTimeout(async () => {
      if (activeNotes.size > 0 && !isEditing) {
        const currentNoteIds = Array.from(activeNotes);
        const notesList = currentNoteIds.map(id => (id as string).includes('bass') ? 'Bass/Chord' : 'Melody');
        
        if (notesList.length > 0) {
            try {
                setChordDesc('Analyzing...');
                const analysis = await analyzeChord(notesList, direction);
                setChordName(analysis.chordName);
                setChordDesc(analysis.description);
            } catch (err) {
                console.error("Analysis failed", err);
                setChordDesc('Analysis error (check API key)');
            }
        }
      } else if (activeNotes.size === 0) {
        setChordName('');
        setChordDesc('Play notes to analyze...');
      }
    }, 1000);
    return () => clearTimeout(timeoutId);
  }, [activeNotes, isEditing, direction, isAiEnabled]);

  return {
    direction,
    setDirection,
    activeNotes,
    isAiEnabled,
    setIsAiEnabled,
    chordName,
    chordDesc,
    handleNoteStart,
    handleNoteStop,
    stopAllNotes // Added this export
  };
};
```

hooks/useBackgroundImage.ts:1-(42)
```
import React, { useState } from 'react';
import { CANDIDATE_PATHS } from '../helpers/appConfig';

export const useBackgroundImage = () => {
  const [bgImageSrc, setBgImageSrc] = useState<string>(CANDIDATE_PATHS[0]);
  const [pathIndex, setPathIndex] = useState(0);
  const [bgStatus, setBgStatus] = useState<'loading' | 'loaded' | 'error'>('loading');
  const [manualPath, setManualPath] = useState('');

  const handleImgError = () => {
    const nextIndex = pathIndex + 1;
    if (nextIndex < CANDIDATE_PATHS.length) {
      setPathIndex(nextIndex);
      setBgImageSrc(CANDIDATE_PATHS[nextIndex]);
    } else {
      setBgStatus('error');
    }
  };

  const handleImgLoad = () => {
    setBgStatus('loaded');
  };

  const applyManualPath = (e: React.FormEvent) => {
    e.preventDefault();
    if(manualPath.trim()) {
        setBgImageSrc(manualPath);
        setBgStatus('loading');
        setPathIndex(-1); 
    }
  };

  return {
    bgImageSrc,
    bgStatus,
    manualPath,
    setManualPath,
    handleImgError,
    handleImgLoad,
    applyManualPath
  };
};
```

hooks/useLayoutEditor.ts:1-(211)
```
import React, { useState, useEffect, useCallback, RefObject } from 'react';
import { Capacitor } from '@capacitor/core';
import { LayoutMap } from '../types';
import { STORAGE_KEY_LAYOUT } from '../helpers/appConfig';
import { generateDefaultLayout } from '../helpers/layoutGenerator';

export const useLayoutEditor = (containerRef: RefObject<HTMLDivElement>) => {
  const [isEditing, setIsEditing] = useState(false);
  const [layout, setLayout] = useState<LayoutMap>({});
  const [selectedButtonId, setSelectedButtonId] = useState<string | null>(null);
  const [dragTarget, setDragTarget] = useState<string | null>(null);

  // Initialize Layout
  useEffect(() => {
    const initLayout = async () => {
      const saved = localStorage.getItem(STORAGE_KEY_LAYOUT);
      if (saved) {
        try {
          setLayout(JSON.parse(saved));
        } catch (e) {
          console.error("Failed to parse saved layout, reverting to default.");
          setLayout(await generateDefaultLayout());
        }
      } else {
        setLayout(await generateDefaultLayout());
      }
    };
    initLayout();
  }, []);

  // Drag Handlers
  const handleDragStart = (e: React.MouseEvent | React.TouchEvent, id: string) => {
    if (!isEditing || !containerRef.current) return;
    setSelectedButtonId(id);
    setDragTarget(id);
  };

  const handleDragMove = useCallback((e: MouseEvent | TouchEvent) => {
    if (!isEditing || !dragTarget || !containerRef.current) return;
    
    const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;
    const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;
    
    const rect = containerRef.current.getBoundingClientRect();
    
    let left = ((clientX - rect.left) / rect.width) * 100;
    let top = ((clientY - rect.top) / rect.height) * 100;

    left = Math.max(0, Math.min(100, left));
    top = Math.max(0, Math.min(100, top));

    setLayout(prev => ({
      ...prev,
      [dragTarget]: { left, top }
    }));
  }, [isEditing, dragTarget, containerRef]);

  const handleDragEnd = useCallback(() => {
    setDragTarget(null);
  }, []);

  // Global Drag Listeners
  useEffect(() => {
    if (isEditing) {
      window.addEventListener('mousemove', handleDragMove);
      window.addEventListener('mouseup', handleDragEnd);
      window.addEventListener('touchmove', handleDragMove, { passive: false });
      window.addEventListener('touchend', handleDragEnd);
    }
    return () => {
      window.removeEventListener('mousemove', handleDragMove);
      window.removeEventListener('mouseup', handleDragEnd);
      window.removeEventListener('touchmove', handleDragMove);
      window.removeEventListener('touchend', handleDragEnd);
    };
  }, [isEditing, handleDragMove, handleDragEnd]);

  // Keyboard Nudge Logic
  useEffect(() => {
    if (!isEditing || !selectedButtonId || !containerRef.current) return;

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Enter') {
        setSelectedButtonId(null);
        return;
      }

      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        e.preventDefault();
        
        const rect = containerRef.current!.getBoundingClientRect();
        const pixelStep = e.shiftKey ? 10 : 1;
        
        const stepX = (pixelStep / rect.width) * 100;
        const stepY = (pixelStep / rect.height) * 100;

        setLayout(prev => {
          const current = prev[selectedButtonId] || { left: 50, top: 50 };
          let newLeft = current.left;
          let newTop = current.top;

          switch (e.key) {
            case 'ArrowLeft': newLeft -= stepX; break;
            case 'ArrowRight': newLeft += stepX; break;
            case 'ArrowUp': newTop -= stepY; break;
            case 'ArrowDown': newTop += stepY; break;
          }

          return {
            ...prev,
            [selectedButtonId]: { left: newLeft, top: newTop }
          };
        });
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [isEditing, selectedButtonId, containerRef]);

  // Persistence & IO
  const saveLayout = () => {
    localStorage.setItem(STORAGE_KEY_LAYOUT, JSON.stringify(layout));
    setIsEditing(false);
    setSelectedButtonId(null);
  };

  const resetLayout = async () => {
    if (confirm("Are you sure you want to reset the layout?")) {
      const def = await generateDefaultLayout();
      setLayout(def);
      localStorage.setItem(STORAGE_KEY_LAYOUT, JSON.stringify(def));
    }
  };

  const handleImportLayout = (file: File) => {
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const json = JSON.parse(event.target?.result as string);
        if (typeof json === 'object' && json !== null) {
          setLayout(json);
          localStorage.setItem(STORAGE_KEY_LAYOUT, JSON.stringify(json));
          alert("Layout imported successfully!");
        } else {
          alert("Invalid JSON file.");
        }
      } catch (err) {
        console.error("Import error:", err);
        alert("Error reading file.");
      }
    };
    reader.readAsText(file);
  };

  const handleExportLayout = async () => {
    const isAndroid = Capacitor.getPlatform() === 'android';
    const fileName = isAndroid ? 'layout_apk.json' : 'layout.json';
    const dataStr = JSON.stringify(layout, null, 2);

    if (isAndroid) {
      try {
        const file = new File([dataStr], fileName, { type: 'application/json' });
        if (navigator.canShare && navigator.canShare({ files: [file] })) {
          await navigator.share({
            files: [file],
            title: 'Steirische Layout Export',
            text: 'Layout configuration for Android.'
          });
          return;
        }
      } catch (e) {
        console.error("Share failed", e);
      }
      
      // Fallback to clipboard
      try {
        await navigator.clipboard.writeText(dataStr);
        alert(`Export failed. JSON copied to clipboard instead! Save as ${fileName}.`);
      } catch (e) {
        alert("Export failed. Could not share or copy to clipboard.");
      }
      return;
    }

    // Web Download
    const blob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = fileName;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  };

  return {
    layout,
    isEditing,
    setIsEditing,
    selectedButtonId,
    setSelectedButtonId,
    dragTarget,
    handleDragStart,
    saveLayout,
    resetLayout,
    handleImportLayout,
    handleExportLayout
  };
};
```

hooks/useMidiPlayer.ts:1-(979)
```
import { useState, useEffect, useRef } from 'react';
import { Midi } from '@tonejs/midi';
import { Direction, MidiProject, SavedDirectionEvent } from '../types';
import { getButtonIdForNote, getButtonIdsForNote, getNoteKey } from '../helpers/midiMap';
import { BASS_ROWS } from '../constants';

export type ChannelMode = 'both' | 'bass' | 'treble' | 'muted' | 'hidden';

export interface MidiNote {
  midi: number;
  time: number;
  duration: number;
  velocity: number;
  channel: number;
  name: string;
}

interface MidiEvent {
  time: number;
  type: 'noteOn' | 'noteOff' | 'direction';
  midi?: number;
  velocity?: number;
  direction?: Direction;
  id?: string;
  noteType?: 'bass' | 'chord' | 'treble';
  channel?: number;
}

export interface DirectionEvent {
  time: number;
  direction: Direction;
}

export const useMidiPlayer = (
  audioController: any
) => {
  // --- State ---
  const [isPlaying, setIsPlaying] = useState(false);
  const [bpm, setBpm] = useState(120);
  const [originalBpm, setOriginalBpm] = useState(120);
  const [currentTime, setCurrentTime] = useState(0);
  const [totalTime, setTotalTime] = useState(0);
  const [fileName, setFileName] = useState<string | null>(null);

  const [availableChannels, setAvailableChannels] = useState<number[]>([]);
  const [channelModes, setChannelModes] = useState<Record<number, ChannelMode>>({});
  const [allNotes, setAllNotes] = useState<MidiNote[]>([]);
  
  // New: Direction Events & Octave Shift
  const [directionEvents, setDirectionEvents] = useState<DirectionEvent[]>([]);
  const [octaveShift, setOctaveShiftState] = useState(0);
  const [semitoneShift, setSemitoneShiftState] = useState(0); // New State
  const [isScrubbingSoundEnabled, setIsScrubbingSoundEnabled] = useState(false);
  
  // Project Storage State
  const [rawMidiBase64, setRawMidiBase64] = useState<string | null>(null);
  const [currentProjectId, setCurrentProjectId] = useState<string | null>(null);
  const [isAutoSaveEnabled, setIsAutoSaveEnabled] = useState(true);

  // New: Fingering Override State
  const [fingeringOverrides, setFingeringOverrides] = useState<Record<string, string>>({});
  const fingeringOverridesRef = useRef<Record<string, string>>({});
  const [flashingNotes, setFlashingNotes] = useState<Set<string>>(new Set()); // Visual feedback
  const [alternativeButtons, setAlternativeButtons] = useState<Set<string>>(new Set());
  const [autoScrollMode, setAutoScrollMode] = useState<'treble' | 'bass' | 'off'>('treble');
  const [isNoteSnapEnabled, setIsNoteSnapEnabled] = useState(false);

  const cycleAutoScrollMode = () => {
    setAutoScrollMode(prev => {
      if (prev === 'treble') return 'bass';
      if (prev === 'bass') return 'off';
      return 'treble';
    });
  };

  useEffect(() => {
    fingeringOverridesRef.current = fingeringOverrides;
  }, [fingeringOverrides]);

  // Clear flashing notes after render
  useEffect(() => {
    if (flashingNotes.size > 0) {
      const timer = setTimeout(() => {
        setFlashingNotes(new Set());
      }, 300);
      return () => clearTimeout(timer);
    }
  }, [flashingNotes]);

  const [editingNote, setEditingNote] = useState<{ midi: number, time: number, channel: number } | null>(null);

  const setFingeringOverride = (midi: number, time: number, channel: number, btnId: string) => {
    const targetKey = getNoteKey(midi, time, channel);
    
    // Batch Logic: Propagate to subsequent identical notes
    const newOverrides = { ...fingeringOverrides };
    const newFlashing = new Set<string>();
    
    // 1. Apply to target
    newOverrides[targetKey] = btnId;
    newFlashing.add(targetKey);

    // 2. Find start index and propagate
    const startIndex = allNotes.findIndex(n =>
        n.midi === midi && Math.abs(n.time - time) < 0.001 && n.channel === channel
    );

    if (startIndex !== -1) {
        let currentTarget = allNotes[startIndex];

        for (let i = startIndex + 1; i < allNotes.length; i++) {
            const nextNote = allNotes[i];
            if (nextNote.channel !== channel) continue;
            
            if (nextNote.midi === midi) {
                // Found same note - update override and current reference
                const nextKey = getNoteKey(nextNote.midi, nextNote.time, nextNote.channel);
                newOverrides[nextKey] = btnId;
                newFlashing.add(nextKey);
                currentTarget = nextNote;
            } else {
                // Different note - check if it's harmony or melody
                
                // 1. Overlap with current target note? (Harmony of previous/current)
                // If it starts before the current note ends (with small buffer), it's simultaneous/harmony
                if (nextNote.time < (currentTarget.time + currentTarget.duration - 0.05)) {
                    continue;
                }

                // 2. Overlap with a future target note? (Harmony of next)
                // Look ahead to find the next instance of the target note
                let futureTarget = null;
                for (let j = i + 1; j < allNotes.length; j++) {
                    if (allNotes[j].channel === channel && allNotes[j].midi === midi) {
                        futureTarget = allNotes[j];
                        break;
                    }
                }

                if (futureTarget) {
                    // Check if nextNote overlaps with futureTarget
                    // Since notes are sorted by time, nextNote.time <= futureTarget.time
                    // We just need to check if nextNote ends after futureTarget starts (with buffer)
                    if ((nextNote.time + nextNote.duration) > (futureTarget.time + 0.05)) {
                         continue;
                    }
                }

                // If neither, it's a melodic interruption -> Break chain
                break;
            }
        }
    }

    setFingeringOverrides(newOverrides);
    fingeringOverridesRef.current = newOverrides; // Sync Ref immediately
    
    // Trigger Flash
    setFlashingNotes(newFlashing);

    // Immediate visual update if paused
    if (!isPlaying) {
      setTimeout(() => seek(currentTime), 0);
    }
  };

  const clearSelection = () => setEditingNote(null);

  const selectNote = (note: MidiNote) => {
    // Cycle Logic if already editing this note
    if (editingNote &&
        editingNote.midi === note.midi &&
        Math.abs(editingNote.time - note.time) < 0.001 &&
        editingNote.channel === note.channel) {
        
        const dir = directionRef.current;
        const shiftedMidi = note.midi + (octaveShiftRef.current * 12) + semitoneShiftRef.current;
        const candidates = getButtonIdsForNote(shiftedMidi, dir);
        
        if (candidates.length > 1) {
            const key = getNoteKey(note.midi, note.time, note.channel);
            // Use Ref to get the absolute latest state
            const currentId = fingeringOverridesRef.current[key];
            
            let nextIndex = 0;
            if (currentId) {
                const currIdx = candidates.indexOf(currentId);
                if (currIdx !== -1) {
                    nextIndex = (currIdx + 1) % candidates.length;
                }
            } else {
                // Default to second option if no override exists yet
                nextIndex = 1 % candidates.length;
            }
            
            setFingeringOverride(note.midi, note.time, note.channel, candidates[nextIndex]);
        }
        return;
    }

    setIsPlaying(false);
    // Seek slightly into the note (50ms) to avoid start-boundary overlaps with previous notes
    seek(note.time + 0.05);
    setEditingNote({ midi: note.midi, time: note.time, channel: note.channel });
  };

  // --- Refs ---
  const eventQueue = useRef<MidiEvent[]>([]);
  const eventIndex = useRef(0);
  const startTimeRef = useRef(0);
  const pausedTimeRef = useRef(0);
  const animationFrameRef = useRef<number>();
  const directionRef = useRef<Direction>(Direction.PUSH);
  // Store btnId AND channel to allow re-triggering on direction change
  const activeMidiMapping = useRef<Map<number, { btnId: string, channel: number }>>(new Map());
  const octaveShiftRef = useRef(0);
  const semitoneShiftRef = useRef(0); // New Ref
  const activeScrubbingNotes = useRef<Set<string>>(new Set());

  // --- Helpers ---

  const setOctaveShift = (val: number) => {
    setOctaveShiftState(val);
    octaveShiftRef.current = val;
    activeScrubbingNotes.current.clear(); // Fix desync
    audioController.stopAllNotes();
  };

  const setSemitoneShift = (val: number) => {
    setSemitoneShiftState(val);
    semitoneShiftRef.current = val;
    activeScrubbingNotes.current.clear(); // Fix desync
    audioController.stopAllNotes();
  };

  const cycleChannelMode = (channel: number) => {
    setChannelModes(prev => {
      const current = prev[channel] || 'muted';
      let next: ChannelMode = 'treble';
      if (current === 'muted') next = 'treble';
      else if (current === 'treble') next = 'bass';
      else if (current === 'bass') next = 'hidden';
      else next = 'muted'; // from hidden back to muted

      activeScrubbingNotes.current.clear(); // Fix desync
      audioController.stopAllNotes();
      return { ...prev, [channel]: next };
    });
  };

  const updateDirections = (updates: { time: number, direction: Direction }[]) => {
    // 1. Update State
    setDirectionEvents(prev => {
      const newEvents = [...prev];
      updates.forEach(update => {
        const idx = newEvents.findIndex(e => Math.abs(e.time - update.time) < 0.001);
        if (idx >= 0) newEvents.splice(idx, 1);
        newEvents.push(update);
      });
      return newEvents.sort((a, b) => a.time - b.time);
    });

    // 2. Update Event Queue
    const currentQueue = eventQueue.current;
    const filteredQueue = currentQueue.filter(e => {
      if (e.type !== 'direction') return true;
      return !updates.some(u => Math.abs(u.time - e.time) < 0.001);
    });

    updates.forEach(u => {
      filteredQueue.push({ time: u.time, type: 'direction', direction: u.direction });
    });

    filteredQueue.sort((a, b) => {
      if (a.time !== b.time) return a.time - b.time;
      if (a.type === 'direction' && b.type !== 'direction') return -1;
      if (a.type !== 'direction' && b.type === 'direction') return 1;
      return 0;
    });

    eventQueue.current = filteredQueue;
  };

  const loadMidiFile = async (file: File) => {
    const reader = new FileReader();
    reader.onload = async (e) => {
      const result = e.target?.result;
      if (typeof result === 'string') {
        // result is DataURL: "data:audio/midi;base64,..."
        const base64 = result.split(',')[1];
        setRawMidiBase64(base64);
        
        // Decode for Tone.js
        const binaryString = atob(base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        await parseAndLoadMidi(bytes.buffer, file.name);
        setCurrentProjectId(null); // New file = new project context
      }
    };
    reader.readAsDataURL(file);
  };

  const parseAndLoadMidi = async (buffer: ArrayBuffer, name: string) => {
    const midi = new Midi(buffer);
    setFileName(name);
    
    if (midi.header.tempos.length > 0) {
      setOriginalBpm(Math.round(midi.header.tempos[0].bpm));
      setBpm(Math.round(midi.header.tempos[0].bpm));
    }
    setTotalTime(midi.duration);

    const events: MidiEvent[] = [];
    const foundChannels = new Set<number>();
    const initialDirEvents: DirectionEvent[] = [];

    midi.tracks.forEach(track => {
      foundChannels.add(track.channel);
      track.notes.forEach(note => {
        events.push({ time: note.time, type: 'noteOn', midi: note.midi, velocity: note.velocity, channel: track.channel });
        events.push({ time: note.time + note.duration, type: 'noteOff', midi: note.midi, channel: track.channel });
      });
      // @ts-ignore
      const trackEvents = track.events || [];
      trackEvents.forEach((e: any) => {
          if (e.type === 'text' || e.type === 'meta') {
              const text = (e.text || '').toUpperCase();
              if (text.includes('PUSH')) {
                  events.push({ time: e.time, type: 'direction', direction: Direction.PUSH });
                  initialDirEvents.push({ time: e.time, direction: Direction.PUSH });
              } else if (text.includes('PULL')) {
                  events.push({ time: e.time, type: 'direction', direction: Direction.PULL });
                  initialDirEvents.push({ time: e.time, direction: Direction.PULL });
              }
          }
      });
    });

    const parsedNotes: MidiNote[] = [];
    midi.tracks.forEach(track => {
      track.notes.forEach(note => {
        parsedNotes.push({
          midi: note.midi,
          time: note.time,
          duration: note.duration,
          velocity: note.velocity,
          channel: track.channel,
          name: note.name
        });
      });
    });
    parsedNotes.sort((a, b) => a.time - b.time);
    setAllNotes(parsedNotes);
    setDirectionEvents(initialDirEvents.sort((a, b) => a.time - b.time));

    setAvailableChannels(Array.from(foundChannels).sort((a, b) => a - b));
    const initialModes: Record<number, ChannelMode> = {};
    foundChannels.forEach(ch => { initialModes[ch] = 'muted'; });
    setChannelModes(initialModes);

    events.sort((a, b) => {
      if (a.time !== b.time) return a.time - b.time;
      if (a.type === 'direction' && b.type !== 'direction') return -1;
      if (a.type !== 'direction' && b.type === 'direction') return 1;
      return 0;
    });
    
    eventQueue.current = events;
    resetPlayer();
  };

  const resetPlayer = () => {
    setIsPlaying(false);
    setCurrentTime(0);
    eventIndex.current = 0;
    pausedTimeRef.current = 0;
    directionRef.current = Direction.PUSH;
    activeMidiMapping.current.clear();
    activeScrubbingNotes.current.clear();
    audioController.stopAllNotes();
  };

  const togglePlay = () => {
    if (isPlaying) {
      setIsPlaying(false);
      pausedTimeRef.current = currentTime;
      if (animationFrameRef.current) cancelAnimationFrame(animationFrameRef.current);
      audioController.stopAllNotes();
    } else {
      setIsPlaying(true);
      directionRef.current = audioController.direction;
      startTimeRef.current = performance.now() - (pausedTimeRef.current * 1000 * (originalBpm / bpm));
      
      // Stop any scrubbing notes
      activeScrubbingNotes.current.forEach(id => audioController.handleNoteStop(id));
      activeScrubbingNotes.current.clear();

      // Rebuild activeMidiMapping if empty (e.g. after seek)
      if (activeMidiMapping.current.size === 0) {
         const time = pausedTimeRef.current;
         const dir = directionRef.current;
         
         allNotes.forEach(note => {
             if (time >= note.time && time < note.time + note.duration) {
                 const mode = channelModes[note.channel] || 'muted';
                 if (mode === 'muted' || mode === 'hidden') return;
                 
                 const shiftedMidi = note.midi + (octaveShiftRef.current * 12) + semitoneShiftRef.current;
                 const candidates = getButtonIdsForNote(shiftedMidi, dir);
                 const validCandidates = candidates.filter(id => {
                     const isBass = id.startsWith('bass');
                     if (mode === 'bass' && !isBass) return false;
                     if (mode === 'treble' && isBass) return false;
                     return true;
                 });
                 
                 if (validCandidates.length > 0) {
                     const key = getNoteKey(note.midi, note.time, note.channel);
                     let btnId = fingeringOverridesRef.current[key];
                     if (!btnId || !validCandidates.includes(btnId)) btnId = validCandidates[0];
                     activeMidiMapping.current.set(note.midi, { btnId, channel: note.channel });
                 }
             }
         });
      }

      // Re-trigger all notes in mapping
      activeMidiMapping.current.forEach((data, midi) => {
          const shiftedMidi = midi + (octaveShiftRef.current * 12) + semitoneShiftRef.current;
          const isBassRow = data.btnId.startsWith('bass');
          let type: 'bass' | 'chord' | 'treble' = 'treble';
          let chordType = undefined;
          
          if (isBassRow) {
             const [_, rStr, bStr] = data.btnId.split('-');
             const r = parseInt(rStr);
             const b = parseInt(bStr);
             const def = BASS_ROWS.find(row => row.rowId === r)?.buttons[b];
             if (def) {
                 const noteDef = directionRef.current === Direction.PUSH ? def.push : def.pull;
                 type = noteDef.type as any;
                 chordType = noteDef.chordType;
             }
          }
          
          audioController.handleNoteStart(
              data.btnId,
              { midi: shiftedMidi, label: 'Resume' },
              type,
              chordType,
              directionRef.current
          );
      });

      loop();
    }
  };

  // --- Smart Fingering Solver ---
  const solveAndPlayBatch = (events: MidiEvent[]) => {
    const currentDir = directionRef.current;
    // Extract btnIds from the mapping objects
    const activeIds = Array.from(activeMidiMapping.current.values()).map((v: { btnId: string, channel: number }) => v.btnId);
    
    // 1. Prepare Candidates
    const notesToSolve: { event: MidiEvent, candidates: string[] }[] = [];
    
    events.forEach(e => {
       const mode = e.channel !== undefined ? (channelModes[e.channel] || 'muted') : 'both';
       if (mode === 'muted' || mode === 'hidden') return;
       
       // Apply Octave AND Semitone Shift
       const shiftedMidi = e.midi! + (octaveShiftRef.current * 12) + semitoneShiftRef.current;
       
       // Get Candidates
       const allIds = getButtonIdsForNote(shiftedMidi, currentDir);
       const candidates = allIds.filter(id => {
          const isBass = id.startsWith('bass');
          if (mode === 'bass' && !isBass) return false;
          if (mode === 'treble' && isBass) return false;
          return true;
       });

       if (candidates.length === 0) return;

       // Check Override
       const key = getNoteKey(e.midi!, e.time, e.channel || 0);
       const overrideId = fingeringOverridesRef.current[key];

       let validIds = candidates;
       if (overrideId && candidates.includes(overrideId)) {
         validIds = [overrideId];
       }
       
       notesToSolve.push({ event: e, candidates: validIds });
    });

    if (notesToSolve.length === 0) return;

    // 2. Solver (Minimize Distance)
    let bestCost = Infinity;
    let bestAssignment: string[] = [];

    const getCost = (id1: string, id2: string) => {
        const p1 = id1.split('-');
        const p2 = id2.split('-');
        // type-row-col
        if (p1[0] !== p2[0]) return 100; // Different hands (infinite distance)
        const r1 = parseInt(p1[1]), c1 = parseInt(p1[2]);
        const r2 = parseInt(p2[1]), c2 = parseInt(p2[2]);
        // Heuristic: Row changes are "expensive" (4x), column changes are "cheap" (1x)
        return Math.abs(c1 - c2) + Math.abs(r1 - r2) * 4;
    };

    const search = (idx: number, current: string[]) => {
        if (idx === notesToSolve.length) {
            let cost = 0;
            // Internal spread (pairwise among new notes)
            for (let i = 0; i < current.length; i++) {
                for (let j = i + 1; j < current.length; j++) {
                    cost += getCost(current[i], current[j]);
                }
            }
            // Distance to existing hand position (active notes)
            for (let i = 0; i < current.length; i++) {
                for (const active of activeIds) {
                    cost += getCost(current[i], active);
                }
            }
            
            if (cost < bestCost) {
                bestCost = cost;
                bestAssignment = [...current];
            }
            return;
        }

        const candidates = notesToSolve[idx].candidates;
        for (const cand of candidates) {
            current.push(cand);
            search(idx + 1, current);
            current.pop();
        }
    };

    search(0, []);

    // 3. Play Selected Buttons
    bestAssignment.forEach((btnId, idx) => {
        const event = notesToSolve[idx].event;
        // Apply Shifts
        const shiftedMidi = event.midi! + (octaveShiftRef.current * 12) + semitoneShiftRef.current;
        
        // Store btnId AND channel
        activeMidiMapping.current.set(event.midi!, { btnId, channel: event.channel || 0 });
        
        const isBassRow = btnId.startsWith('bass');
        let type: 'bass' | 'chord' | 'treble' = 'treble';
        let chordType = undefined;
        
        if (isBassRow) {
             const [_, rStr, bStr] = btnId.split('-');
             const r = parseInt(rStr);
             const b = parseInt(bStr);
             const def = BASS_ROWS.find(row => row.rowId === r)?.buttons[b];
             if (def) {
                 const noteDef = currentDir === Direction.PUSH ? def.push : def.pull;
                 type = noteDef.type as any;
                 chordType = noteDef.chordType;
             }
        }
        
        audioController.handleNoteStart(btnId, { midi: shiftedMidi, label: 'MIDI' }, type, chordType, currentDir);
    });
  };

  const deleteChannel = (channel: number) => {
    // 1. Stop active notes for this channel
    activeMidiMapping.current.forEach((data, midi) => {
      if (data.channel === channel) {
        audioController.handleNoteStop(data.btnId);
        activeMidiMapping.current.delete(midi);
      }
    });

    // 2. Remove from State
    setAvailableChannels(prev => prev.filter(c => c !== channel));
    setChannelModes(prev => {
      const next = { ...prev };
      delete next[channel];
      return next;
    });
    setAllNotes(prev => prev.filter(n => n.channel !== channel));
    
    // 3. Clean up Event Queue (keep global events or other channels)
    eventQueue.current = eventQueue.current.filter(e => e.channel === undefined || e.channel !== channel);
  };

  const loop = () => {
    const now = performance.now();
    const rawElapsed = (now - startTimeRef.current) / 1000;
    const speedRatio = bpm / originalBpm;
    const scaledTime = rawElapsed * speedRatio;

    setCurrentTime(scaledTime);

    const batch: MidiEvent[] = [];

    const flushBatch = () => {
      if (batch.length === 0) return;
      solveAndPlayBatch(batch);
      batch.length = 0;
    };

    while (eventIndex.current < eventQueue.current.length) {
      const event = eventQueue.current[eventIndex.current];
      if (event.time > scaledTime) break;

      if (event.type === 'noteOn') {
        batch.push(event);
      } else {
        // Flush pending notes before changing direction or stopping notes
        flushBatch();
        processEvent(event);
      }
      eventIndex.current++;
    }
    flushBatch();

    if (scaledTime >= totalTime) {
      setIsPlaying(false);
      return;
    }

    if (isPlaying) {
       animationFrameRef.current = requestAnimationFrame(loop);
    }
  };

  useEffect(() => {
    if (isPlaying) {
      animationFrameRef.current = requestAnimationFrame(loop);
    }
    return () => {
      if (animationFrameRef.current) cancelAnimationFrame(animationFrameRef.current);
    };
  }, [isPlaying, bpm]);

  const processEvent = (event: MidiEvent) => {
    // NoteOn is now handled by solveAndPlayBatch in the loop
    
    if (event.type === 'direction' && event.direction) {
      const newDir = event.direction;
      if (directionRef.current !== newDir) {
          // 1. Capture currently playing notes
          const activeNotesData = Array.from(activeMidiMapping.current.entries());
          
          // 2. Stop everything physically
          audioController.stopAllNotes();
          activeMidiMapping.current.clear();
          
          // 3. Update Direction
          audioController.setDirection(newDir);
          directionRef.current = newDir;
          
          // 4. Re-trigger notes in new direction (if they exist)
          if (activeNotesData.length > 0) {
              const syntheticEvents: MidiEvent[] = activeNotesData.map(([midi, data]) => ({
                  time: currentTime,
                  type: 'noteOn',
                  midi: midi,
                  velocity: 0.8,
                  channel: data.channel
              }));
              solveAndPlayBatch(syntheticEvents);
          }
      }
      return;
    }

    if (!event.midi) return;

    if (event.type === 'noteOff') {
      const data = activeMidiMapping.current.get(event.midi);
      if (data) {
        audioController.handleNoteStop(data.btnId);
        activeMidiMapping.current.delete(event.midi);
      }
    }
  };
  const syncScrubbingNotes = (time: number) => {
    // 1. Determine Direction
    let dir = Direction.PUSH;
    if (directionEvents.length > 0) {
      let left = 0;
      let right = directionEvents.length - 1;
      let lastValidIndex = -1;
      while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        const event = directionEvents[mid];
        if (event.time <= time + 0.001) {
          lastValidIndex = mid;
          left = mid + 1;
        } else {
          right = mid - 1;
        }
      }
      if (lastValidIndex >= 0) {
        dir = directionEvents[lastValidIndex].direction;
      }
    }
    
    if (dir !== directionRef.current) {
      directionRef.current = dir;
      audioController.setDirection(dir);
      activeScrubbingNotes.current.forEach(id => audioController.handleNoteStop(id));
      activeScrubbingNotes.current.clear();
    }

    // 2. Gather Notes
    const notesToSolve: { note: MidiNote, candidates: string[], allCandidates: string[], shiftedMidi: number }[] = [];

    allNotes.forEach(note => {
      if (time >= note.time && time < note.time + note.duration - 0.03) {
        const mode = channelModes[note.channel] || 'muted';
        if (mode === 'muted' || mode === 'hidden') return;

        const shiftedMidi = note.midi + (octaveShiftRef.current * 12) + semitoneShiftRef.current;
        const allBtnIds = getButtonIdsForNote(shiftedMidi, dir);
        
        const candidates = allBtnIds.filter(btnId => {
            const isBassBtn = btnId.startsWith('bass');
            const isTrebleBtn = btnId.startsWith('treble');
            if (mode === 'bass' && !isBassBtn) return false;
            if (mode === 'treble' && !isTrebleBtn) return false;
            return true;
        });

        if (candidates.length === 0) return;

        const key = getNoteKey(note.midi, note.time, note.channel);
        const overrideId = fingeringOverridesRef.current[key];

        let validIds = candidates;
        if (overrideId && candidates.includes(overrideId)) {
            validIds = [overrideId];
        }

        notesToSolve.push({ note, candidates: validIds, allCandidates: candidates, shiftedMidi });
      }
    });

    // 3. Group by Time & Sort
    const groups = new Map<number, typeof notesToSolve>();
    notesToSolve.forEach(item => {
        const t = item.note.time;
        if (!groups.has(t)) groups.set(t, []);
        groups.get(t)!.push(item);
    });
    const sortedTimes = Array.from(groups.keys()).sort((a, b) => a - b);

    // 4. Incremental Solve
    const finalAssignment: string[] = [];
    const prevActive: string[] = Array.from(activeScrubbingNotes.current);

    const getCost = (id1: string, id2: string) => {
        const p1 = id1.split('-');
        const p2 = id2.split('-');
        if (p1[0] !== p2[0]) return 100;
        const r1 = parseInt(p1[1]), c1 = parseInt(p1[2]);
        const r2 = parseInt(p2[1]), c2 = parseInt(p2[2]);
        return Math.abs(c1 - c2) + Math.abs(r1 - r2) * 4;
    };

    sortedTimes.forEach(t => {
        const groupItems = groups.get(t)!;
        let bestGroupCost = Infinity;
        let bestGroupAssign: string[] = [];

        const search = (idx: number, current: string[]) => {
            if (idx === groupItems.length) {
                let cost = 0;
                // Internal
                for (let i = 0; i < current.length; i++) {
                    for (let j = i + 1; j < current.length; j++) {
                        cost += getCost(current[i], current[j]);
                    }
                }
                // External (to previously assigned in this frame)
                for (let i = 0; i < current.length; i++) {
                    for (const assigned of finalAssignment) {
                        cost += getCost(current[i], assigned);
                    }
                }
                // External (to prevActive - stability)
                for (let i = 0; i < current.length; i++) {
                    for (const active of prevActive) {
                        cost += getCost(current[i], active);
                    }
                }

                if (cost < bestGroupCost) {
                    bestGroupCost = cost;
                    bestGroupAssign = [...current];
                }
                return;
            }

            const candidates = groupItems[idx].candidates;
            for (const cand of candidates) {
                current.push(cand);
                search(idx + 1, current);
                current.pop();
            }
        };

        search(0, []);
        finalAssignment.push(...bestGroupAssign);
    });

    // 5. Sync & Alternatives
    const nextActiveIds = new Set<string>(finalAssignment);
    const calculatedAlternatives = new Set<string>();

    activeScrubbingNotes.current.forEach(id => {
        if (!nextActiveIds.has(id)) {
            audioController.handleNoteStop(id);
            activeScrubbingNotes.current.delete(id);
        }
    });

    let assignIdx = 0;
    sortedTimes.forEach(t => {
        const groupItems = groups.get(t)!;
        groupItems.forEach(item => {
            const btnId = finalAssignment[assignIdx++];
            
            item.allCandidates.forEach(cand => {
                if (cand !== btnId) calculatedAlternatives.add(cand);
            });

            if (!activeScrubbingNotes.current.has(btnId)) {
                 const isBassRow = btnId.startsWith('bass');
                 let type: 'bass' | 'chord' | 'treble' = 'treble';
                 let chordType = undefined;

                 if (isBassRow) {
                    const [_, rStr, bStr] = btnId.split('-');
                    const r = parseInt(rStr);
                    const b = parseInt(bStr);
                    const def = BASS_ROWS.find(row => row.rowId === r)?.buttons[b];
                    if (def) {
                        const noteDef = dir === Direction.PUSH ? def.push : def.pull;
                        type = noteDef.type as any;
                        chordType = noteDef.chordType;
                    }
                 }

                 audioController.handleNoteStart(
                   btnId,
                   { midi: item.shiftedMidi, label: 'Scrub' },
                   type,
                   chordType,
                   dir,
                   {
                     silent: !isScrubbingSoundEnabled,
                     duration: 2.0
                   }
                 );
                 activeScrubbingNotes.current.add(btnId);
            }
        });
    });
    
    setAlternativeButtons(calculatedAlternatives);
  };

const seek = (time: number) => {
    const newTime = Math.max(0, Math.min(time, totalTime));
    setCurrentTime(newTime);
    
    // Sync eventIndex to new time
    const newIndex = eventQueue.current.findIndex(e => e.time >= newTime);
    eventIndex.current = newIndex === -1 ? eventQueue.current.length : newIndex;
    
    // Clear playback state since we jumped
    activeMidiMapping.current.clear();
    
    if (isPlaying) {
      const speedRatio = bpm / originalBpm;
      startTimeRef.current = performance.now() - (newTime * 1000 / speedRatio);
    } else {
      pausedTimeRef.current = newTime;
      syncScrubbingNotes(newTime);
    }
  };

  const loadProject = async (project: MidiProject) => {
    if (!project.midiBase64) return;
    setRawMidiBase64(project.midiBase64);
    setCurrentProjectId(project.id);
    
    const binaryString = atob(project.midiBase64);
    const len = binaryString.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    
    await parseAndLoadMidi(bytes.buffer, project.name);
    
    setBpm(project.bpm);
    setOctaveShift(project.octaveShift);
    setSemitoneShift(project.semitoneShift || 0); // Load Semitone
    setChannelModes(project.channelModes);
    updateDirections(project.directionEvents);
    setFingeringOverrides(project.fingeringOverrides || {});
    fingeringOverridesRef.current = project.fingeringOverrides || {}; // Restore overrides to Ref
  };

  const getProjectState = (): Omit<MidiProject, 'id' | 'name' | 'lastModified'> | null => {
    if (!rawMidiBase64) return null;
    return {
      midiBase64: rawMidiBase64,
      bpm,
      octaveShift,
      semitoneShift, // Save Semitone
      channelModes,
      directionEvents,
      fingeringOverrides // Save overrides
    };
  };

  return {
    isPlaying,
    currentTime,
    totalTime,
    bpm,
    setBpm,
    fileName,
    loadMidiFile,
    togglePlay,
    resetPlayer,
    availableChannels,
    channelModes,
    cycleChannelMode,
    allNotes,
    seek,
    octaveShift,
    setOctaveShift,
    semitoneShift, // Export
    setSemitoneShift, // Export
    directionEvents,
    updateDirections,
    isScrubbingSoundEnabled,
    setIsScrubbingSoundEnabled,
    currentProjectId,
    loadProject,
    getProjectState,
    alternativeButtons,
    setFingeringOverride,
    editingNote,
    selectNote,
    clearSelection,
    flashingNotes,
    deleteChannel,
    autoScrollMode,
    cycleAutoScrollMode,
    isNoteSnapEnabled,
    setIsNoteSnapEnabled,
    isAutoSaveEnabled,
    setIsAutoSaveEnabled
  };
};
```

hooks/useSoundSettings.ts:1-(48)
```
import { useState, useEffect } from 'react';
import { SoundSettings } from '../types';
import { audioService } from '../services/audioService';
import { STORAGE_KEY_SOUND, DEFAULT_SOUND_SETTINGS } from '../helpers/appConfig';

export const useSoundSettings = () => {
  const [settings, setSettings] = useState<SoundSettings>(() => {
    try {
      const saved = localStorage.getItem(STORAGE_KEY_SOUND);
      // Merge saved settings with defaults to ensure new keys (like inputGain) exist
      return saved ? { ...DEFAULT_SOUND_SETTINGS, ...JSON.parse(saved) } : DEFAULT_SOUND_SETTINGS;
    } catch (e) {
      console.error("Failed to load sound settings", e);
      return DEFAULT_SOUND_SETTINGS;
    }
  });

  // Sync with AudioService on mount/change
  useEffect(() => {
    audioService.updateSettings(settings);
  }, [settings]);

  const updateSetting = (key: keyof SoundSettings, value: number) => {
    const newSettings = { ...settings, [key]: value };
    setSettings(newSettings);
    audioService.updateSettings(newSettings);
    localStorage.setItem(STORAGE_KEY_SOUND, JSON.stringify(newSettings));
  };

  const resetSetting = (key: keyof SoundSettings) => {
    updateSetting(key, DEFAULT_SOUND_SETTINGS[key]);
  };

  const resetAllSettings = () => {
    if (confirm("Reset all sound settings to default?")) {
      setSettings(DEFAULT_SOUND_SETTINGS);
      audioService.updateSettings(DEFAULT_SOUND_SETTINGS);
      localStorage.setItem(STORAGE_KEY_SOUND, JSON.stringify(DEFAULT_SOUND_SETTINGS));
    }
  };

  return {
    settings,
    updateSetting,
    resetSetting,
    resetAllSettings
  };
};
```

index.html:1-(35)
```
<!DOCTYPE html>
<html lang="nl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Steirische Harmonika Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* Custom scrollbar for a cleaner look */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #f1f5f9; 
      }
      ::-webkit-scrollbar-thumb {
        background: #cbd5e1; 
        border-radius: 4px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #94a3b8; 
      }
      
      .wood-pattern {
        background-color: #f8fafc;
        background-image: repeating-linear-gradient(45deg, rgba(0,0,0,0.02) 0px, rgba(0,0,0,0.02) 2px, transparent 2px, transparent 10px);
      }
    </style>
</head>
  <body class="bg-gray-50 text-gray-900 overflow-hidden">
    <div id="root"></div>
  <script type="module" src="/index.tsx"></script>
</body>
</html>
```

index.tsx:1-(15)
```
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

metadata.json:1-(5)
```
{
  "name": "Steirische Simulator (B-Es-As-Des)",
  "description": "Een virtuele Steirische Harmonika met B-Es-As-Des stemming. Speel melodie en bas, wissel tussen duwen en trekken, en leer noten met AI-ondersteuning.",
  "requestFramePermissions": []
}
```

package.json:1-(30)
```
{
  "name": "steirische-simulator-(b-es-as-des)",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@capacitor/android": "^6.0.0",
    "@capacitor/app": "^6.0.0",
    "@capacitor/core": "^6.0.0",
    "@google/genai": "^1.30.0",
    "@heroicons/react": "^2.2.0",
    "@tonejs/midi": "^2.0.28",
    "react": "^19.2.0",
    "react-dom": "^19.2.0"
  },
  "devDependencies": {
    "@capacitor/assets": "^3.0.5",
    "@capacitor/cli": "^6.0.0",
    "@types/node": "^22.14.0",
    "@vitejs/plugin-react": "^5.0.0",
    "typescript": "~5.8.2",
    "vite": "^6.2.0"
  }
}
```

public/assets/accordion_line_drawing.png:1-(1)
```
# [binary file omitted]
```

public/assets/icon.png:1-(1)
```
# [binary file omitted]
```

public/assets/ui_bass_apk.png:1-(1)
```
# [binary file omitted]
```

public/assets/ui_bass.png:1-(1)
```
# [binary file omitted]
```

public/assets/ui_bellow.png:1-(1)
```
# [binary file omitted]
```

public/assets/ui_trebble_apk.png:1-(1)
```
# [binary file omitted]
```

public/assets/ui_trebble.png:1-(1)
```
# [binary file omitted]
```

README.md:1-(21)
```
<div align="center">
<img width="1200" height="475" alt="GHBanner" src="https://github.com/user-attachments/assets/0aa67016-6eaf-458a-adb2-6e31a0763ed6" />
</div>

# Run and deploy your AI Studio app

This contains everything you need to run your app locally.

View your app in AI Studio: https://ai.studio/apps/drive/12LHxn8Y174EcJYAbhUibuNNbbf7WC7L6

## Run Locally

**Prerequisites:**  Node.js


1. Install dependencies:
   `npm install`
2. Set the `GEMINI_API_KEY` in [.env.local](.env.local) to your Gemini API key
3. Run the app:
   `npm run dev`
```

services/audio/generators.ts:1-(81)
```
// file: services/audio/generators.ts
import { SoundSettings } from '../../types';

export const midiToFreq = (midi: number): number => {
  return 440 * Math.pow(2, (midi - 69) / 12);
};

export const makeDistortionCurve = (amount: number): Float32Array => {
  const k = amount;
  const n_samples = 44100;
  const curve = new Float32Array(n_samples);
  const deg = Math.PI / 180;
  if (amount === 0) {
      for (let i = 0; i < n_samples; ++i) curve[i] = (i / n_samples) * 2 - 1;
      return curve;
  }
  for (let i = 0; i < n_samples; ++i) {
    const x = (i * 2) / n_samples - 1;
    curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
  }
  return curve;
};

export const generateReverbImpulse = (ctx: AudioContext, duration: number): AudioBuffer => {
  const rate = ctx.sampleRate;
  const length = rate * duration;
  const impulse = ctx.createBuffer(2, length, rate);
  const left = impulse.getChannelData(0);
  const right = impulse.getChannelData(1);
  for (let i = 0; i < length; i++) {
    const decay = Math.pow(1 - i / length, 2); // Exponential decay
    left[i] = (Math.random() * 2 - 1) * decay;
    right[i] = (Math.random() * 2 - 1) * decay;
  }
  return impulse;
};

export const generateNoiseBuffer = (ctx: AudioContext): AudioBuffer => {
  const bufferSize = ctx.sampleRate * 2; 
  const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
  const data = buffer.getChannelData(0);
  let b0=0, b1=0, b2=0, b3=0, b4=0, b5=0, b6=0;
  for (let i = 0; i < bufferSize; i++) {
    const white = Math.random() * 2 - 1;
    b0 = 0.99886 * b0 + white * 0.0555179;
    b1 = 0.99332 * b1 + white * 0.0750759;
    b2 = 0.96900 * b2 + white * 0.1538520;
    b3 = 0.86650 * b3 + white * 0.3104856;
    b4 = 0.55000 * b4 + white * 0.5329522;
    b5 = -0.7616 * b5 - white * 0.0168980;
    data[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
    data[i] *= 0.11; 
    b6 = white * 0.115926;
  }
  return buffer;
};

export const generateTrebleWave = (ctx: AudioContext, settings: SoundSettings): PeriodicWave => {
  const numCoeffs = 128;
  const real = new Float32Array(numCoeffs);
  const imag = new Float32Array(numCoeffs);
  for (let n = 1; n < numCoeffs; n++) {
    let amp = 1.0 / Math.pow(n, 2.5 - settings.harmonicBrightness); // Brightness control
    if (n === 3) amp *= 1.5; 
    if (n === 5) amp *= 1.2; 
    imag[n] = amp;
  }
  return ctx.createPeriodicWave(real, imag);
};

export const generateBassWave = (ctx: AudioContext, settings: SoundSettings): PeriodicWave => {
  const numCoeffs = 128;
  const real = new Float32Array(numCoeffs);
  const imag = new Float32Array(numCoeffs);
  for (let n = 1; n < numCoeffs; n++) {
    let amp = 1.0 / Math.pow(n, 0.9); 
    if (n % 2 === 0) amp *= (1.0 + settings.bassGrowl); // Growl control
    imag[n] = amp;
  }
  return ctx.createPeriodicWave(real, imag);
};
```

services/audio/internalTypes.ts:1-(36)
```
// file: services/audio/internalTypes.ts
import { SoundSettings } from '../../types';

export interface ActiveVoice {
  sourceNodes: AudioScheduledSourceNode[]; 
  gain: GainNode; 
  nodesToDisconnect: AudioNode[];
  // References for real-time updates
  panner: StereoPannerNode;
  peakFilter: BiquadFilterNode;
  lpFilter: BiquadFilterNode;
  noiseGain: GainNode;
  oscillators: OscillatorNode[]; 
  baseFreq: number; 
  type: 'bass' | 'chord' | 'treble';
  startTime: number;
}

export interface AudioResources {
  trebleWave: PeriodicWave | null;
  bassWave: PeriodicWave | null;
  noiseBuffer: AudioBuffer | null;
}

export interface MasterChain {
  preGain: GainNode;
  inputLimiter: DynamicsCompressorNode;
  tubeDistortion: WaveShaperNode;
  eqLowNode: BiquadFilterNode;
  eqMidNode: BiquadFilterNode;
  eqHighNode: BiquadFilterNode;
  reverbNode: ConvolverNode;
  dryGain: GainNode;
  wetGain: GainNode;
  masterGain: GainNode;
}
```

services/audio/master.ts:1-(92)
```
// file: services/audio/master.ts
import { SoundSettings } from '../../types';
import { MasterChain } from './internalTypes';
import { makeDistortionCurve, generateReverbImpulse } from './generators';

export const setupMasterChain = (ctx: AudioContext, settings: SoundSettings): MasterChain => {
  // Chain: PreGain -> Saturation -> EQ -> Reverb/Dry -> Limiter -> Master -> Dest

  const preGain = ctx.createGain();
  preGain.gain.value = settings.inputGain;

  const tubeDistortion = ctx.createWaveShaper();
  // Cast to any to resolve TS mismatch
  tubeDistortion.curve = makeDistortionCurve(0) as any;
  tubeDistortion.oversample = '4x';

  const eqLowNode = ctx.createBiquadFilter();
  eqLowNode.type = 'lowshelf';
  eqLowNode.frequency.value = 200;

  const eqMidNode = ctx.createBiquadFilter();
  eqMidNode.type = 'peaking';
  eqMidNode.frequency.value = 1000;
  eqMidNode.Q.value = 1;

  const eqHighNode = ctx.createBiquadFilter();
  eqHighNode.type = 'highshelf';
  eqHighNode.frequency.value = 3000;

  // Reverb Send
  const reverbNode = ctx.createConvolver();
  reverbNode.buffer = generateReverbImpulse(ctx, settings.reverbSize);
  
  const dryGain = ctx.createGain();
  const wetGain = ctx.createGain();

  // Limiter (Compressor) - Now at the end of the chain
  const inputLimiter = ctx.createDynamicsCompressor();
  inputLimiter.threshold.value = -2; // Higher threshold for safety
  inputLimiter.ratio.value = 12;
  inputLimiter.attack.value = 0.003;
  inputLimiter.release.value = 0.25;
  
  const masterGain = ctx.createGain();
  masterGain.gain.value = settings.masterVolume;

  // Connect Graph
  preGain.connect(tubeDistortion);
  tubeDistortion.connect(eqLowNode);
  eqLowNode.connect(eqMidNode);
  eqMidNode.connect(eqHighNode);

  // Split to Dry/Wet
  eqHighNode.connect(dryGain);
  eqHighNode.connect(reverbNode);
  reverbNode.connect(wetGain);

  // Sum to Limiter -> Master
  dryGain.connect(inputLimiter);
  wetGain.connect(inputLimiter);
  inputLimiter.connect(masterGain);
  masterGain.connect(ctx.destination);

  return {
    preGain,
    inputLimiter,
    tubeDistortion,
    eqLowNode,
    eqMidNode,
    eqHighNode,
    reverbNode,
    dryGain,
    wetGain,
    masterGain
  };
};

export const updateMasterChain = (ctx: AudioContext, chain: MasterChain, settings: SoundSettings) => {
  const now = ctx.currentTime;
  
  chain.preGain.gain.setTargetAtTime(settings.inputGain, now, 0.05);
  chain.masterGain.gain.setTargetAtTime(settings.masterVolume, now, 0.05);
  chain.eqLowNode.gain.setTargetAtTime(settings.eqLow, now, 0.1);
  chain.eqMidNode.gain.setTargetAtTime(settings.eqMid, now, 0.1);
  chain.eqHighNode.gain.setTargetAtTime(settings.eqHigh, now, 0.1);
  
  chain.dryGain.gain.setTargetAtTime(1 - settings.reverbMix, now, 0.1);
  chain.wetGain.gain.setTargetAtTime(settings.reverbMix, now, 0.1);

  // Cast to any to resolve TS mismatch
  chain.tubeDistortion.curve = makeDistortionCurve(settings.tubeSaturation) as any;
};
```

services/audio/mechanics.ts:1-(70)
```
// file: services/audio/mechanics.ts
import { SoundSettings } from '../../types';
import { MasterChain } from './internalTypes';

export const playMechanicalSound = (
  ctx: AudioContext, 
  masterChain: MasterChain, 
  settings: SoundSettings, 
  time: number, 
  type: 'click' | 'thud', 
  isBass: boolean
) => {
  // 1. Get Base Volume
  let vol = type === 'click' ? settings.buttonClickVolume : settings.palletThudVolume;
  
  // 2. Apply Square Law (makes slider feel more natural)
  vol = vol * vol;

  if (vol <= 0.001) return; // Silence threshold

  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  const filter = ctx.createBiquadFilter();

  // Randomness
  const rand = (Math.random() - 0.5) * settings.mechanismNoiseRandomness;
  
  // 3. Calculate Modifiers BEFORE scheduling
  let freqMult = 1.0;
  let volMult = 1.0;
  
  if (isBass && settings.bassButtonClunk > 0) {
      freqMult = (1.0 - settings.bassButtonClunk * 0.4); // Lower pitch
      volMult = (1.0 + settings.bassButtonClunk * 0.5); // Louder
  }

  if (type === 'click') {
      // Sharp click (Attack)
      osc.type = 'sine';
      const baseFreq = isBass ? 150 : 300;
      osc.frequency.setValueAtTime((baseFreq + (rand * 50)) * freqMult, time);
      osc.frequency.exponentialRampToValueAtTime(50, time + 0.05);
      
      filter.type = 'lowpass';
      filter.frequency.value = (isBass ? 800 : 1500) * freqMult;
      
      const peakVol = vol * volMult;
      gain.gain.setValueAtTime(peakVol, time);
      // Use LINEAR ramp to 0 to ensure it actually fades out completely and scales correctly
      gain.gain.linearRampToValueAtTime(0, time + 0.03); 
  } else {
      // Dull thud (Release)
      osc.type = 'triangle';
      const baseFreq = 80;
      osc.frequency.setValueAtTime((baseFreq + (rand * 20)) * freqMult, time);
      osc.frequency.exponentialRampToValueAtTime(20, time + 0.1);
      
      filter.type = 'lowpass';
      filter.frequency.value = 300 * freqMult;
      
      const peakVol = vol * 0.8 * volMult;
      gain.gain.setValueAtTime(peakVol, time);
      // Use LINEAR ramp to 0
      gain.gain.linearRampToValueAtTime(0, time + 0.08); 
  }

  osc.connect(filter).connect(gain).connect(masterChain.preGain);
  osc.start(time);
  osc.stop(time + 0.15);
};
```

services/audio/voice.ts:1-(262)
```
// file: services/audio/voice.ts
import { SoundSettings, Direction } from '../../types';
import { ActiveVoice, AudioResources, MasterChain } from './internalTypes';
import { midiToFreq } from './generators';

// Helper to create a single oscillator
const createOscillator = (
  ctx: AudioContext, 
  destination: AudioNode, 
  freq: number, 
  baseVol: number, 
  wave: PeriodicWave, 
  tracker: AudioScheduledSourceNode[],
  oscTracker: OscillatorNode[],
  now: number,
  settings: SoundSettings,
  applyLFO: boolean = false,
  fixedDetune: number = 0
) => {
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();

  if (wave) osc.setPeriodicWave(wave);
  else osc.type = 'sawtooth';

  osc.frequency.value = freq;
  
  // Pitch Instability + Bellows Bend
  const drift = (Math.random() - 0.5) * settings.pitchInstability;
  const bend = settings.bellowsPitchBend; // Usually negative
  osc.detune.value = fixedDetune + drift - bend;

  // Bellows Shake LFO
  if (settings.bellowsShakeDepth > 0) {
      const shake = ctx.createOscillator();
      shake.frequency.value = settings.bellowsShakeSpeed;
      const shakeGain = ctx.createGain();
      shakeGain.gain.value = settings.bellowsShakeDepth * 10; // Pitch wobble
      shake.connect(shakeGain).connect(osc.detune);
      shake.start(now);
      tracker.push(shake);
      
      // Also modulate volume
      const volShake = ctx.createGain();
      volShake.gain.value = settings.bellowsShakeDepth * 0.2;
      shake.connect(volShake).connect(gain.gain);
  }

  if (applyLFO) {
    const lfo = ctx.createOscillator();
    lfo.type = 'sine';
    lfo.frequency.value = 5 + Math.random() * 2; 
    const lfoGain = ctx.createGain();
    lfoGain.gain.value = 4; 
    lfo.connect(lfoGain).connect(osc.detune);
    lfo.start(now);
    tracker.push(lfo);
  }

  const randomLevel = 0.95 + (Math.random() * 0.1);
  gain.gain.value = baseVol * randomLevel;

  const randomOffset = Math.random() * 0.015;

  osc.connect(gain).connect(destination);
  osc.start(now + randomOffset);
  
  tracker.push(osc);
  oscTracker.push(osc);
};

export const createVoice = (
  ctx: AudioContext,
  masterChain: MasterChain,
  resources: AudioResources,
  settings: SoundSettings,
  midi: number,
  type: 'bass' | 'chord' | 'treble',
  chordType: string = 'major',
  direction: Direction = Direction.PUSH
): ActiveVoice => {
  const now = ctx.currentTime;
  const isBass = type === 'bass';

  // 1. Channel Strip
  const envelopeGain = ctx.createGain();
  envelopeGain.gain.setValueAtTime(0, now);

  const panner = ctx.createStereoPanner();
  const width = isBass ? settings.bassStereoWidth : settings.trebleStereoWidth;
  panner.pan.value = (Math.random() * width * 2) - width;

  const hpFilter = ctx.createBiquadFilter();
  hpFilter.type = 'highpass';
  hpFilter.frequency.value = isBass ? 40 : 100;

  const peakFilter = ctx.createBiquadFilter();
  peakFilter.type = 'peaking';
  peakFilter.frequency.value = isBass ? 200 : settings.boxResonanceFreq;
  peakFilter.Q.value = 1.5;
  peakFilter.gain.value = isBass ? settings.bassChamberResonance : settings.boxResonanceAmount;

  const lpFilter = ctx.createBiquadFilter();
  lpFilter.type = 'lowpass';
  let cutoff = settings.grilleFilterCutoff;
  if (isBass) cutoff = 800;
  if (settings.cassottoEffect > 0 && !isBass) cutoff *= (1 - settings.cassottoEffect * 0.5);
  lpFilter.frequency.value = cutoff;

  // Push/Pull Variance (Subtle EQ shift)
  if (settings.pushPullVariance > 0) {
      if (direction === Direction.PULL) {
          peakFilter.frequency.value *= 1.1; // Pulling tightens the box slightly
      }
  }

  hpFilter.connect(peakFilter);
  peakFilter.connect(lpFilter);
  lpFilter.connect(panner);
  panner.connect(envelopeGain);
  envelopeGain.connect(masterChain.preGain);

  const sourceNodes: AudioScheduledSourceNode[] = [];
  const oscNodes: OscillatorNode[] = [];
  const nodesToDisconnect: AudioNode[] = [hpFilter, peakFilter, lpFilter, panner, envelopeGain];

  // 2. Air Noise
  const noiseGain = ctx.createGain();
  if (resources.noiseBuffer && settings.airNoiseLevel > 0) {
    const noiseNode = ctx.createBufferSource();
    noiseNode.buffer = resources.noiseBuffer;
    noiseNode.loop = true;
    
    const baseNoise = isBass ? 1.5 : 1.0;
    noiseGain.gain.value = settings.airNoiseLevel * baseNoise;
    
    // Turbulence LFO
    if (settings.airTurbulence > 0) {
        const lfo = ctx.createOscillator();
        lfo.frequency.value = 0.5 + Math.random();
        const lfoGain = ctx.createGain();
        lfoGain.gain.value = settings.airTurbulence * 0.01;
        lfo.connect(lfoGain).connect(noiseGain.gain);
        lfo.start(now);
        sourceNodes.push(lfo);
    }

    const noiseFilter = ctx.createBiquadFilter();
    noiseFilter.type = 'bandpass';
    noiseFilter.frequency.value = 1500;
    noiseFilter.Q.value = 1;

    noiseNode.connect(noiseFilter).connect(noiseGain).connect(panner);
    noiseNode.start(now);
    sourceNodes.push(noiseNode);
    nodesToDisconnect.push(noiseGain, noiseFilter);
  }

  // 3. Voice Config
  const freq = midiToFreq(midi);
  const attack = settings.reedAttackTime * settings.reedStiffness;

  if (type === 'bass') {
    envelopeGain.gain.linearRampToValueAtTime(0.95, now + attack * 1.5);
    
    // Reduced gains to prevent clipping (0.6 -> 0.35)
    createOscillator(ctx, hpFilter, freq, 0.35, resources.bassWave!, sourceNodes, oscNodes, now, settings, true, -2);
    createOscillator(ctx, hpFilter, freq, 0.35, resources.bassWave!, sourceNodes, oscNodes, now, settings, true, 2);
    // Octave (0.2 -> 0.15)
    createOscillator(ctx, hpFilter, freq * 2, 0.15 * settings.bassOctaveBalance, resources.bassWave!, sourceNodes, oscNodes, now, settings);

  } else if (type === 'chord') {
    envelopeGain.gain.linearRampToValueAtTime(0.8, now + attack);

    let voicing: [number, number][] = [];
    if (chordType === 'major') voicing = [[0, 0.30], [4, 0.50], [7, 0.50], [12, 0.75], [16, 0.40], [19, 0.35], [24, 0.20]];
    else if (chordType === 'minor') voicing = [[0, 0.30], [3, 0.50], [7, 0.50], [12, 0.75], [15, 0.40], [19, 0.35], [24, 0.20]];
    else voicing = [[0, 0.30], [4, 0.50], [10, 0.45], [12, 0.75], [16, 0.40], [22, 0.30], [24, 0.20]];

    voicing.forEach(([interval, vol], index) => {
      const noteFreq = midiToFreq(midi + interval);
      const useLFO = index === 3;
      // Reduced multiplier (0.25 -> 0.15)
      createOscillator(ctx, hpFilter, noteFreq, vol * 0.15, resources.trebleWave!, sourceNodes, oscNodes, now, settings, useLFO);
    });

  } else {
    // Treble
    envelopeGain.gain.linearRampToValueAtTime(1.0, now + attack);

    // Reduced gains (0.3/0.25 -> 0.2/0.15)
    createOscillator(ctx, hpFilter, freq, 0.2, resources.trebleWave!, sourceNodes, oscNodes, now, settings, true);
    createOscillator(ctx, hpFilter, freq, 0.15, resources.trebleWave!, sourceNodes, oscNodes, now, settings, false, settings.musetteDetune);
    createOscillator(ctx, hpFilter, freq, 0.15, resources.trebleWave!, sourceNodes, oscNodes, now, settings, false, -settings.musetteDetune);
    
    if (settings.trebleOctaveBalance > 0) {
        createOscillator(ctx, hpFilter, freq * 2, 0.1 * settings.trebleOctaveBalance, resources.trebleWave!, sourceNodes, oscNodes, now, settings);
    }
  }

  return { 
    sourceNodes, 
    gain: envelopeGain, 
    nodesToDisconnect,
    panner,
    peakFilter,
    lpFilter,
    noiseGain,
    oscillators: oscNodes,
    baseFreq: freq,
    type,
    startTime: now
  };
};

export const updateVoice = (voice: ActiveVoice, settings: SoundSettings, now: number) => {
  // Box Resonance
  const isBass = voice.type === 'bass';
  const resFreq = isBass ? 200 : settings.boxResonanceFreq;
  const resGain = isBass ? settings.bassChamberResonance : settings.boxResonanceAmount;
  
  voice.peakFilter.frequency.setTargetAtTime(resFreq, now, 0.1);
  voice.peakFilter.gain.setTargetAtTime(resGain, now, 0.1);

  // Grille / Brightness
  let cutoff = settings.grilleFilterCutoff;
  if (isBass) cutoff = 800; // Bass always lower
  if (settings.cassottoEffect > 0 && !isBass) {
    cutoff *= (1 - settings.cassottoEffect * 0.5); // Cassotto muffles highs
  }
  voice.lpFilter.frequency.setTargetAtTime(cutoff, now, 0.1);

  // Air Noise
  const baseNoise = isBass ? 1.5 : 1.0;
  voice.noiseGain.gain.setTargetAtTime(settings.airNoiseLevel * baseNoise, now, 0.1);

  // Musette Detune (Treble/Chord only)
  if (!isBass) {
    voice.oscillators.forEach((osc, idx) => {
       // idx 1 = sharp, idx 2 = flat
       if (idx === 1) osc.detune.setTargetAtTime(settings.musetteDetune + settings.bellowsPitchBend, now, 0.1);
       if (idx === 2) osc.detune.setTargetAtTime(-settings.musetteDetune + settings.bellowsPitchBend, now, 0.1);
       if (idx === 0) osc.detune.setTargetAtTime(settings.bellowsPitchBend, now, 0.1);
    });
  }
};

export const stopVoice = (voice: ActiveVoice, ctx: AudioContext, settings: SoundSettings) => {
  const now = ctx.currentTime;
  
  voice.gain.gain.cancelScheduledValues(now);
  voice.gain.gain.setValueAtTime(voice.gain.gain.value, now);
  // Use Release Time Setting
  voice.gain.gain.exponentialRampToValueAtTime(0.001, now + settings.reedReleaseTime);

  voice.sourceNodes.forEach(node => node.stop(now + settings.reedReleaseTime + 0.1));
  
  setTimeout(() => {
    voice.gain.disconnect();
    voice.nodesToDisconnect.forEach(node => node.disconnect());
  }, (settings.reedReleaseTime * 1000) + 200);
};
```

services/audioService.ts:1-(126)
```
// file: services/audioService.ts
import { SoundSettings, Direction } from '../types';
import { ActiveVoice, AudioResources, MasterChain } from './audio/internalTypes';
import { setupMasterChain, updateMasterChain } from './audio/master';
import { generateTrebleWave, generateBassWave, generateNoiseBuffer } from './audio/generators';
import { playMechanicalSound } from './audio/mechanics';
import { createVoice, updateVoice, stopVoice } from './audio/voice';

class AudioService {
  private context: AudioContext | null = null;
  private masterChain: MasterChain | null = null;
  private activeVoices: Map<string, ActiveVoice> = new Map();
  private resources: AudioResources = {
    trebleWave: null,
    bassWave: null,
    noiseBuffer: null
  };

  // Default Settings (will be overwritten by App)
  private settings: SoundSettings = {
    musetteDetune: 14, reedAttackTime: 0.03, reedReleaseTime: 0.15, pitchInstability: 2, bellowsPitchBend: 0,
    harmonicBrightness: 1.0, bassGrowl: 1.0, reedStiffness: 1.0, trebleOctaveBalance: 0.5, bassOctaveBalance: 0.5,
    airNoiseLevel: 0.03, airTurbulence: 0.5, bellowsShakeSpeed: 5, bellowsShakeDepth: 0, dynamicRange: 1.0, pushPullVariance: 0,
    buttonClickVolume: 0.4, palletThudVolume: 0.3, mechanismNoiseRandomness: 0.2, bassButtonClunk: 0.5,
    boxResonanceFreq: 400, boxResonanceAmount: 4, grilleFilterCutoff: 5000, cassottoEffect: 0, bassChamberResonance: 2,
    tubeSaturation: 0, inputGain: 0.5, trebleStereoWidth: 0.3, bassStereoWidth: 0.1, reverbSize: 1.5, reverbMix: 0.1,
    eqLow: 0, eqMid: 0, eqHigh: 0, masterVolume: 0.4
  };

  constructor() {}

  init() {
    if (!this.context) {
      this.context = new (window.AudioContext || (window as any).webkitAudioContext)();
      
      // 1. Setup Master Chain
      this.masterChain = setupMasterChain(this.context, this.settings);

      // 2. Generate Assets
      this.regenerateAssets();
    }
  }

  private regenerateAssets() {
    if (!this.context) return;
    this.resources.trebleWave = generateTrebleWave(this.context, this.settings);
    this.resources.bassWave = generateBassWave(this.context, this.settings);
    if (!this.resources.noiseBuffer) {
      this.resources.noiseBuffer = generateNoiseBuffer(this.context);
    }
  }

  updateSettings(newSettings: SoundSettings) {
    this.settings = newSettings;
    if (!this.context || !this.masterChain) return;
    const now = this.context.currentTime;

    // 1. Update Master Chain
    updateMasterChain(this.context, this.masterChain, this.settings);

    // 2. Regenerate Waveforms (if harmonic params changed)
    // Optimization: Could check if specific params changed, but for now we regen
    this.regenerateAssets();

    // 3. Update Active Voices
    this.activeVoices.forEach(voice => {
      updateVoice(voice, this.settings, now);
    });
  }

  playNote(noteId: string, midi: number, type: 'bass' | 'chord' | 'treble', chordType: 'major' | 'minor' | '7th' | 'none' = 'major', direction: Direction = Direction.PUSH, options?: { duration?: number }) {
    if (!this.context) this.init();
    if (this.activeVoices.has(noteId)) return;
    if (!this.masterChain) return;

    const ctx = this.context!;
    const now = ctx.currentTime;
    const isBass = type === 'bass';

    // 1. Mechanical Click
    playMechanicalSound(ctx, this.masterChain, this.settings, now, 'click', isBass || type === 'chord');

    // 2. Create Voice
    const voice = createVoice(
      ctx,
      this.masterChain,
      this.resources,
      this.settings,
      midi,
      type,
      chordType,
      direction
    );

    this.activeVoices.set(noteId, voice);

    // Auto-stop if duration provided
    if (options?.duration) {
      setTimeout(() => {
        this.stopNote(noteId);
      }, options.duration * 1000);
    }
  }

  stopNote(noteId: string) {
    if (!this.context || !this.masterChain) return;
    const voice = this.activeVoices.get(noteId);
    if (voice) {
      const now = this.context.currentTime;
      
      // Mechanical Release Thud
      playMechanicalSound(this.context, this.masterChain, this.settings, now, 'thud', voice.type === 'bass' || voice.type === 'chord');

      // Stop Voice
      stopVoice(voice, this.context, this.settings);
      
      this.activeVoices.delete(noteId);
    }
  }

  stopAll() {
    this.activeVoices.forEach((_, key) => this.stopNote(key));
  }
}

export const audioService = new AudioService();
```

services/geminiService.ts:1-(56)
```
import { GoogleGenAI } from "@google/genai";
import { ChordAnalysis } from "../types";

// Safe initialization
const apiKey = process.env.API_KEY;
const ai = apiKey ? new GoogleGenAI({ apiKey }) : null;

export const analyzeChord = async (notes: string[], direction: string): Promise<ChordAnalysis> => {
  if (!ai) {
    return {
      chordName: "No API Key",
      description: "AI functionality disabled.",
      notes: notes
    };
  }

  try {
    const prompt = `
      I am playing a Steirische Harmonika (Styrian Accordion).
      Bellows direction: ${direction}.
      The currently pressed notes are: ${notes.join(', ')}.
      
      Please analyze this combination. 
      1. What chord is this? (e.g., "Eb Major", "Bb Dominant 7th").
      2. Provide a very short description (1 sentence) in Dutch.
      
      Return JSON format:
      {
        "chordName": "Name",
        "description": "Dutch description",
        "notes": ["List", "Of", "Notes"]
      }
    `;

    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: prompt,
      config: {
        responseMimeType: 'application/json'
      }
    });

    const text = response.text;
    if (!text) throw new Error("No response from Gemini");
    return JSON.parse(text) as ChordAnalysis;

  } catch (error) {
    console.error("Gemini Error:", error);
    return {
      chordName: "Onbekend",
      description: "Kon de harmonie niet analyseren.",
      notes: notes
    };
  }
};
```

src/vite-env.d.ts:1-(6)
```
/// <reference types="vite/client" />

interface ImportMeta {
  glob(pattern: string, options?: { eager?: boolean }): Record<string, unknown>;
}
```

steirische-simulator-APK.code-workspace:1-(10)
```
{
	"folders": [
		{
			"path": "."
		}
	],
	"settings": {
		"java.configuration.updateBuildConfiguration": "automatic"
	}
}
```

tsconfig.json:1-(29)
```
{
  "compilerOptions": {
    "target": "ES2022",
    "experimentalDecorators": true,
    "useDefineForClassFields": false,
    "module": "ESNext",
    "lib": [
      "ES2022",
      "DOM",
      "DOM.Iterable"
    ],
    "skipLibCheck": true,
    "types": [
      "node"
    ],
    "moduleResolution": "bundler",
    "isolatedModules": true,
    "moduleDetection": "force",
    "allowJs": true,
    "jsx": "react-jsx",
    "paths": {
      "@/*": [
        "./*"
      ]
    },
    "allowImportingTsExtensions": true,
    "noEmit": true
  }
}
```

types.ts:1-(94)
```
// file: types.ts

export enum Direction {
  PUSH = 'push',
  PULL = 'pull'
}

export interface NoteDefinition {
  midi: number;
  label: string;
  type: 'treble' | 'bass' | 'chord';
  chordType?: string;
}

export interface ButtonPosition {
  left: number;
  top: number;
}

export interface LayoutMap {
  [key: string]: ButtonPosition;
}

export interface ChordAnalysis {
  chordName: string;
  description: string;
  notes: string[];
}

export interface SoundSettings {
  // Category 1: Reed Physics & Tuning
  musetteDetune: number;      // 0-50 cents
  reedAttackTime: number;     // 0.001-0.1s
  reedReleaseTime: number;    // 0.05-0.5s
  pitchInstability: number;   // 0-10 cents (random drift)
  bellowsPitchBend: number;   // 0-20 cents (flattening)
  harmonicBrightness: number; // 0.5-2.0 (Waveform shape)
  bassGrowl: number;          // 0-2.0 (Even harmonic boost)
  reedStiffness: number;      // 0.5-2.0 (Attack curve modifier)
  trebleOctaveBalance: number;// 0-1 (Mix of high octave)
  bassOctaveBalance: number;  // 0-1 (Mix of upper bass octave)

  // Category 2: Bellows & Air
  airNoiseLevel: number;      // 0-0.2
  airTurbulence: number;      // 0-1 (LFO on noise)
  bellowsShakeSpeed: number;  // 0-10 Hz
  bellowsShakeDepth: number;  // 0-1 (Amplitude mod)
  dynamicRange: number;       // 0-1 (Compression ratio inverse)
  pushPullVariance: number;   // 0-1 (Timbre shift)

  // Category 3: Mechanics
  buttonClickVolume: number;  // 0-1
  palletThudVolume: number;   // 0-1
  mechanismNoiseRandomness: number; // 0-1
  bassButtonClunk: number;    // 0-1 (Bass click EQ/Pitch)

  // Category 4: Body & Resonance
  boxResonanceFreq: number;   // 200-800 Hz
  boxResonanceAmount: number; // 0-20 dB
  grilleFilterCutoff: number; // 1000-10000 Hz
  cassottoEffect: number;     // 0-1 (Tone chamber simulation)
  bassChamberResonance: number; // 0-20 dB

  // Category 5: Audio Effects & Environment
  tubeSaturation: number;     // 0-100
  inputGain: number;          // 0-2.0 (Pre-amp drive)
  trebleStereoWidth: number;  // 0-1
  bassStereoWidth: number;    // 0-1
  reverbSize: number;         // 0.1-5.0s
  reverbMix: number;          // 0-1
  eqLow: number;              // -20 to +20 dB
  eqMid: number;              // -20 to +20 dB
  eqHigh: number;             // -20 to +20 dB
  
  masterVolume: number;       // 0-1
}

export interface SavedDirectionEvent {
  time: number;
  direction: Direction;
}

export interface MidiProject {
  id: string;
  name: string;
  lastModified: number;
  midiBase64: string;
  bpm: number;
  octaveShift: number;
  semitoneShift: number; // Added
  channelModes: Record<number, 'both' | 'bass' | 'treble' | 'muted'>;
  directionEvents: SavedDirectionEvent[];
  fingeringOverrides?: Record<string, string>; // Key: "midi-time-channel", Value: buttonId
}
```

vite.config.ts:1-(35)
```
import path from 'path';
import { defineConfig, loadEnv } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig(({ mode }) => {
    const env = loadEnv(mode, '.', '');
    return {
      server: {
        port: 3000,
        host: '0.0.0.0',
      },
      plugins: [react()],
      define: {
        'process.env.API_KEY': JSON.stringify(env.GEMINI_API_KEY),
        'process.env.GEMINI_API_KEY': JSON.stringify(env.GEMINI_API_KEY)
      },
      resolve: {
        alias: {
          '@': path.resolve(__dirname, '.'),
        }
      },
      build: {
        chunkSizeWarningLimit: 1000,
        rollupOptions: {
          output: {
            manualChunks: {
              vendor: ['react', 'react-dom'],
              audio: ['@tonejs/midi']
            }
          }
        }
      }
    };
});
```


